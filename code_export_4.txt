/* start: ./src\components\EditDialog.tsx*/ // src/components/common/EditDialog.tsx 'use client'; import {   Dialog,   DialogContent,   DialogHeader,   DialogTitle,   DialogDescription, } from '@/components/ui/dialog'; import { Button } from '@/components/ui/button'; import { Input } from '@/components/ui/input'; import { Label } from '@/components/ui/label'; import {   Select,   SelectContent,   SelectItem,   SelectTrigger,   SelectValue, } from '@/components/ui/select'; import { Calendar } from '@/components/ui/calendar'; import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'; import { Loader2, CalendarIcon, Clock } from 'lucide-react'; import { useState } from 'react'; import { format } from 'date-fns'; import { SelectMulti } from './SelectMulti';  type StatusOption = {   value: string;   label: string; };  type FieldType = 'text' | 'number' | 'select' | 'selectmulti' | 'date' | 'time' | 'datetime';  type EditDialogProps = {   open: boolean;   onOpenChange: (open: boolean) => void;   title: string;   description?: string;   initialData: Record<string, any>;   fields: {     name: string;     label: string;     type: FieldType;     required?: boolean;     options?: StatusOption[];   }[];   onSubmit: (data: Record<string, any>) => Promise<void>; };  export function EditDialog({   open,   onOpenChange,   title,   description,   initialData,   fields,   onSubmit, }: EditDialogProps) {   const [formData, setFormData] = useState(initialData);   const [isLoading, setIsLoading] = useState(false);    const handleSubmit = async (e: React.FormEvent) => {     e.preventDefault();     setIsLoading(true);     try {       await onSubmit(formData);       onOpenChange(false);     } catch (error) {       console.error('Error submitting form:', error);     } finally {       setIsLoading(false);     }   };    const handleChange = (name: string, value: string | Date | string[]) => {     // Convert Date objects to ISO strings for consistent storage     const formattedValue = value instanceof Date      ? value.toISOString()      : Array.isArray(value)     ? value     : value;     setFormData(prev => ({ ...prev, [name]: formattedValue }));   };    const renderField = (field: {     name: string;     label: string;     type: FieldType;     required?: boolean;     options?: StatusOption[];   }) => {     switch (field.type) {       case 'select':         return (           <Select             value={formData[field.name] || ''}             onValueChange={(value) => handleChange(field.name, value)}           >             <SelectTrigger>               <SelectValue placeholder={`Select ${field.label.toLowerCase()}`} />             </SelectTrigger>             <SelectContent>               {field.options?.map(option => (                 <SelectItem key={option.value} value={option.value}>                   {option.label}                 </SelectItem>               ))}             </SelectContent>           </Select>         );       case 'selectmulti':           return (             <SelectMulti               options={field.options || []}               value={formData[field.name] || []}               onChange={(value) => handleChange(field.name, value)}               placeholder={`Select ${field.label.toLowerCase()}`}             />           );       case 'date':         return (           <Popover>             <PopoverTrigger asChild>               <Button                 variant="outline"                 className="w-full justify-start text-left font-normal"               >                 <CalendarIcon className="mr-2 h-4 w-4" />                 {formData[field.name] ? (                   format(new Date(formData[field.name]), 'PPP')                 ) : (                   <span>Pick a date</span>                 )}               </Button>             </PopoverTrigger>             <PopoverContent className="w-auto p-0">               <Calendar                 mode="single"                 selected={formData[field.name] ? new Date(formData[field.name]) : undefined}                 onSelect={(date) => date && handleChange(field.name, date)}                 initialFocus               />             </PopoverContent>           </Popover>         );        case 'time':         return (           <div className="relative">             <Clock className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />             <Input               type="time"               className="pl-9"               value={formData[field.name] || ''}               onChange={(e) => handleChange(field.name, e.target.value)}               required={field.required}             />           </div>         );        case 'datetime':         return (           <div className="flex gap-2">             <Popover>               <PopoverTrigger asChild>                 <Button                   variant="outline"                   className="w-full justify-start text-left font-normal"                 >                   <CalendarIcon className="mr-2 h-4 w-4" />                   {formData[field.name] ? (                     format(new Date(formData[field.name]), 'PPP')                   ) : (                     <span>Pick a date</span>                   )}                 </Button>               </PopoverTrigger>               <PopoverContent className="w-auto p-0">                 <Calendar                   mode="single"                   selected={formData[field.name] ? new Date(formData[field.name]) : undefined}                   onSelect={(date) => {                     if (date) {                       const current = formData[field.name] ? new Date(formData[field.name]) : new Date();                       date.setHours(current.getHours());                       date.setMinutes(current.getMinutes());                       handleChange(field.name, date);                     }                   }}                   initialFocus                 />               </PopoverContent>             </Popover>             <div className="relative">               <Clock className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />               <Input                 type="time"                 className="pl-9"                 value={formData[field.name] ? format(new Date(formData[field.name]), 'HH:mm') : ''}                 onChange={(e) => {                   const time = e.target.value;                   if (time) {                     const [hours, minutes] = time.split(':');                     const date = formData[field.name] ? new Date(formData[field.name]) : new Date();                     date.setHours(parseInt(hours, 10));                     date.setMinutes(parseInt(minutes, 10));                     handleChange(field.name, date);                   }                 }}                 required={field.required}               />             </div>           </div>         );        default:         return (           <Input             id={field.name}             type={field.type}             value={formData[field.name] || ''}             onChange={(e) => handleChange(field.name, e.target.value)}             required={field.required}           />         );     }   };    return (     <Dialog open={open} onOpenChange={onOpenChange}>       <DialogContent>         <DialogHeader>           <DialogTitle>{title}</DialogTitle>           {description && <DialogDescription>{description}</DialogDescription>}         </DialogHeader>                  <form onSubmit={handleSubmit} className="space-y-4">           {fields.map(field => (             <div key={field.name} className="space-y-2">               <Label htmlFor={field.name}>                 {field.label}                 {field.required && <span className="text-red-500 ml-1">*</span>}               </Label>               {renderField(field)}             </div>           ))}                      <div className="flex justify-end gap-2 pt-4">             <Button               variant="outline"               type="button"               onClick={() => onOpenChange(false)}               disabled={isLoading}             >               Cancel             </Button>             <Button type="submit" disabled={isLoading}>               {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}               Submit             </Button>           </div>         </form>       </DialogContent>     </Dialog>   ); } /* end: ./src\components\EditDialog.tsx *//* start: ./src\components\Footer.tsx*/ "use client";  import * as React from "react"; import { Moon, Sun } from "lucide-react"; import { useTheme } from "next-themes"; import { Button } from "@/components/ui/button";  // ModeToggle Component: Simple Light/Dark Switch function ModeToggle() {   const { theme, setTheme } = useTheme();    const toggleTheme = () => {     setTheme(theme === "dark" ? "light" : "dark");   };    return (     <Button variant="outline" size="icon" onClick={toggleTheme} className="ml-4">       <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />       <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />       <span className="sr-only">Toggle theme</span>     </Button>   ); }  // Footer Component export default function Footer() {   return (     <footer className="w-full bg-background border-t">       <div className="container mx-auto px-4 h-14 flex items-center justify-center gap-4">         <h3 className="text-lg font-semibold text-foreground">RepairRadar</h3>         <ModeToggle />       </div>       <div className="container mx-auto px-4 py-2 text-center text-sm text-muted-foreground">         Â© {new Date().getFullYear()} RepairRadar. All rights reserved.       </div>     </footer>   ); } /* end: ./src\components\Footer.tsx *//* start: ./src\components\ModeToggle.tsx*/ "use client"  import * as React from "react" import { Moon, Sun } from "lucide-react" import { useTheme } from "next-themes"  import { Button } from "@/components/ui/button" import {   DropdownMenu,   DropdownMenuContent,   DropdownMenuItem,   DropdownMenuTrigger, } from "@/components/ui/dropdown-menu"  export function ModeToggle() {   const { setTheme } = useTheme()    return (     <DropdownMenu>       <DropdownMenuTrigger asChild>         <Button variant="outline" size="icon">           <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />           <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />           <span className="sr-only">Toggle theme</span>         </Button>       </DropdownMenuTrigger>       <DropdownMenuContent align="end">         <DropdownMenuItem onClick={() => setTheme("light")}>           Light         </DropdownMenuItem>         <DropdownMenuItem onClick={() => setTheme("dark")}>           Dark         </DropdownMenuItem>         <DropdownMenuItem onClick={() => setTheme("system")}>           System         </DropdownMenuItem>       </DropdownMenuContent>     </DropdownMenu>   ) }  /* end: ./src\components\ModeToggle.tsx *//* start: ./src\components\SelectMulti.tsx*/ // src/components/ui/select-multi.tsx 'use client';  import * as React from 'react'; import { Check, ChevronsUpDown } from 'lucide-react'; import { Button } from '@/components/ui/button'; import {   Command,   CommandEmpty,   CommandGroup,   CommandInput,   CommandItem, } from '@/components/ui/command'; import {   Popover,   PopoverContent,   PopoverTrigger, } from '@/components/ui/popover'; import { cn } from '@/lib/utils';  type Option = {   value: string;   label: string; };  interface SelectMultiProps {   options: Option[];   value: string[];   onChange: (value: string[]) => void;   placeholder?: string;   className?: string; }  export function SelectMulti({   options,   value = [],   onChange,   placeholder = 'Select options...',   className, }: SelectMultiProps) {   const [open, setOpen] = React.useState(false);    const handleSelect = (optionValue: string) => {     const newValue = value.includes(optionValue)       ? value.filter(v => v !== optionValue)       : [...value, optionValue];     onChange(newValue);   };    return (     <Popover open={open} onOpenChange={setOpen}>       <PopoverTrigger asChild>         <Button           variant="outline"           role="combobox"           aria-expanded={open}           className={cn('w-full justify-between', className)}         >           {value.length > 0             ? options                 .filter(option => value.includes(option.value))                 .map(option => option.label)                 .join(', ')             : placeholder}           <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />         </Button>       </PopoverTrigger>       <PopoverContent className="w-full p-0">         <Command>           <CommandInput placeholder="Search options..." />           <CommandEmpty>No option found.</CommandEmpty>           <CommandGroup>             {options.map(option => (               <CommandItem                 key={option.value}                 onSelect={() => handleSelect(option.value)}               >                 <Check                   className={cn(                     'mr-2 h-4 w-4',                     value.includes(option.value) ? 'opacity-100' : 'opacity-0'                   )}                 />                 {option.label}               </CommandItem>             ))}           </CommandGroup>         </Command>       </PopoverContent>     </Popover>   ); } /* end: ./src\components\SelectMulti.tsx *//* start: ./src\components\ThemeWrapper.tsx*/ "use client"  import * as React from "react" import { ThemeProvider as NextThemesProvider } from "next-themes"  export function ThemeProvider({   children,   ...props }: React.ComponentProps<typeof NextThemesProvider>) {   return <NextThemesProvider {...props}>{children}</NextThemesProvider> } /* end: ./src\components\ThemeWrapper.tsx *//* start: ./src\lib\query.ts*/ "use server";  import { createClient } from "@/utils/supabase/server"; import { Asset, CallStatus, Call, WorkOrderStatus, WorkOrderPriority, WorkOrder, UserRole, MaintenanceStatus, MaintenancePriority } from "./types"; import { SupabaseClient } from "@supabase/supabase-js";  export const queryHelper = async (client?: SupabaseClient) => {     const supabase = client || await createClient();          return {       // Authentication (unchanged)       cl: supabase,       auth: {         signUp: async (email: string, password: string, userMetadata: Record<string, unknown> = {}) => {           const { data, error } = await supabase.auth.signUp({             email,             password,             options: {               data: userMetadata             }           });           return { data, error };         },         signIn: async (email: string, password: string) => {           const { data, error } = await supabase.auth.signInWithPassword({             email,             password,           });           return { data, error };         },         signOut: async () => {           const { error } = await supabase.auth.signOut();           return { error };         },         getUser: async () => {           const { data: { user } } = await supabase.auth.getUser();           return user;         },         updateUser: async (updates: { email?: string; password?: string; data?: Record<string, unknown> }) => {           const { data, error } = await supabase.auth.updateUser(updates);           return { data, error };         },       },       // Asset Operations with overloads       assets: {         getAll: async (tenantId?: string) => {           let query = supabase             .from('assets')             .select('*')             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }              const { data, error } = await query;           return { data, error };         },         getById: async (id: string, tenantId?: string) => {           let query = supabase             .from('assets')             .select('*')             .eq('id', id)             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }              const { data, error } = await query.single();           return { data, error };         },         create: async (asset: Omit<Asset, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => {           const { data, error } = await supabase             .from('assets')             .insert({               tenant_id: asset.tenantId,               name: asset.name,               //description: asset.description,               //serial_number: asset.serialNumber,               //model: asset.model,               //manufacturer: asset.manufacturer,               //purchase_date: asset.purchaseDate,               //warranty_expiration: asset.warrantyExpiration,               location: asset.location,               //asset_type_id: asset.assetTypeId,               //status: asset.status,               created_at: new Date().toISOString(),               updated_at: new Date().toISOString(),             })             .select()             .single();           return { data, error };         },         update: async (id: string, updates: Partial<Asset>) => {           const { data, error } = await supabase             .from('assets')             .update({               ...(updates.tenantId && { tenant_id: updates.tenantId }),               ...(updates.name && { name: updates.name }),               //...(updates.description && { description: updates.description }),               //...(updates.serialNumber && { serial_number: updates.serialNumber }),               //...(updates.model && { model: updates.model }),               //...(updates.manufacturer && { manufacturer: updates.manufacturer }),               //...(updates.purchaseDate && { purchase_date: updates.purchaseDate }),               //...(updates.warrantyExpiration && { warranty_expiration: updates.warrantyExpiration }),               ...(updates.location && { location: updates.location }),               //...(updates.assetTypeId && { asset_type_id: updates.assetTypeId }),               //...(updates.status && { status: updates.status }),               updated_at: new Date().toISOString(),             })             .eq('id', id)             .select()             .single();           return { data, error };         },         delete: async (id: string) => {           const { data, error } = await supabase             .from('assets')             .update({ deleted_at: new Date().toISOString() })             .eq('id', id)             .select()             .single();           return { data, error };         },       },          // Call Operations with overloads       calls: {         getAll: async (tenantId?: string, filters?: { status?: CallStatus; assetId?: string }) => {           let query = supabase             .from('calls')             .select('*')             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }           if (filters?.status) {             query = query.eq('status', filters.status);           }           if (filters?.assetId) {             query = query.eq('asset_id', filters.assetId);           }              const { data, error } = await query;           return { data, error };         },         create: async (call: Omit<Call, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'status'>) => {           const { data, error } = await supabase             .from('calls')             .insert({               tenant_id: call.tenantId,               asset_id: call.assetId,               //reported_by: call.reportedBy,               issue: call.issue,               call_time: new Date().toISOString(),               status: CallStatus.OPEN,               created_at: new Date().toISOString(),               updated_at: new Date().toISOString(),             })             .select()             .single();           return { data, error };         },         updateStatus: async (id: string, status: CallStatus, tenantId?: string) => {           let query = supabase             .from('calls')             .update({                status,                updated_at: new Date().toISOString()              })             .eq('id', id);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }              const { data, error } = await query.select().single();           return { data, error };         },       },          // Work Order Operations with overloads       workOrders: {         getAll: async (id?: string, tenantId?: string, filters?: {            status?: WorkOrderStatus;           assignedToId?: string;           priority?: WorkOrderPriority;         }) => {           let query = supabase             .from('work_orders')             .select('*')             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }           if (id) {             query = query.eq('id', id);           }           if (filters?.status) {             query = query.eq('status', filters.status);           }           if (filters?.assignedToId) {             query = query.eq('assigned_to_id', filters.assignedToId);           }           if (filters?.priority) {             query = query.eq('priority', filters.priority);           }              const { data, error } = await query;           return { data, error };         },         create: async (workOrder: Omit<WorkOrder, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'status'>) => {           const { data, error } = await supabase             .from('work_orders')             .insert({               tenant_id: workOrder.tenantId,               description: workOrder.description,               priority: workOrder.priority,               due_date: workOrder.dueDate,               status: WorkOrderStatus.PENDING,               created_at: new Date().toISOString(),               updated_at: new Date().toISOString(),             })             .select()             .single();           return { data, error };         },         delete: async (workOrderId: string) => {           const {data, error} = await supabase             .from('work_orders')             .delete()             .eq("id", workOrderId);           return { data, error };         },         assign: async (workOrderId: string, userId: string, tenantId?: string) => {           let query = supabase             .from('work_orders')             .update({               assigned_to_id: userId,               status: WorkOrderStatus.ASSIGNED,               updated_at: new Date().toISOString(),             })             .eq('id', workOrderId);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }              const { data, error } = await query.select().single();           return { data, error };         },         addNote: async (id: string, note: string, createdById: string) => {           const { data, error } = await supabase             .from('work_order_notes')             .insert({               work_order_id: id,               note,               created_by_id: createdById,               created_at: new Date().toISOString(),             })             .select()             .single();           return { data, error };         },         getNotes: async (workOrderId: string) => {           const { data, error } = await supabase             .from('work_order_notes')             .select('*')             .eq('work_order_id', workOrderId)             .order('created_at', { ascending: false });           return { data, error };         },       },          // User Operations with overloads       users: {         getAll: async (userId?: string) => {           let query = supabase             .from('users')             .select('*')             .is('deleted_at', null);              if (userId) {             query = query.eq('id', userId);           }              const { data, error } = await query;           return { data, error };         },         getCurrent: async () => {           let {data: {user}, error} = await supabase.auth.getUser();           return {user, error};         },         updateRole: async (userId: string, role: UserRole, tenantId?: string) => {           let query = supabase             .from('users')             .update({ role })             .eq('id', userId);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }              const { data, error } = await query.select().single();           return { data, error };         },       },          // Maintenance Operations with overloads       maintenance: {         getAllSchedules: async (tenantId?: string, filters?: {           status?: MaintenanceStatus;           assignedToId?: string;           priority?: MaintenancePriority;         }) => {           let query = supabase             .from('maintenance_schedules')             .select('*')             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }           if (filters?.status) {             query = query.eq('status', filters.status);           }           if (filters?.assignedToId) {             query = query.eq('assigned_to_id', filters.assignedToId);           }           if (filters?.priority) {             query = query.eq('priority', filters.priority);           }              const { data, error } = await query;           return { data, error };         },       },          // Parts Operations with overloads       parts: {         getAll: async (tenantId?: string, filters?: {           lowStock?: boolean;         }) => {           let query = supabase             .from('parts')             .select('*')             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }           if (filters?.lowStock) {             query = query.lte('quantity', 'min_stock');           }              const { data, error } = await query;           return { data, error };         },       },        vendors: {         getAll: async (tenantId?: string) => {           let query = supabase             .from('vendors')             .select('*')             .is('deleted_at', null);              if (tenantId) {             query = query.eq('tenant_id', tenantId);           }              const { data, error } = await query;           return { data, error };         },       },              tenants: {         getAll: async (tenantId?: string) => {             let query = supabase               .from('tenants')               .select('name, subdomain, id, parent_id, tenant_configs (modules)')               .is('deleted_at', null);                  if (tenantId) {               query = query.eq('tenant_id', tenantId);             }                  const { data, error } = await query;             return { data, error };           },       }     }; }; /* end: ./src\lib\query.ts *//* start: ./src\lib\types.ts*/ export enum CallStatus {   OPEN = 'OPEN',   IN_PROGRESS = 'IN_PROGRESS',   COMPLETED = 'COMPLETED',   CLOSED = 'CLOSED' }  export enum MaintenanceStatus {   SCHEDULED = 'SCHEDULED',   IN_PROGRESS = 'IN_PROGRESS',   COMPLETED = 'COMPLETED',   OVERDUE = 'OVERDUE' }  export enum MaintenancePriority {   LOW = 'LOW',   MEDIUM = 'MEDIUM',   HIGH = 'HIGH',   CRITICAL = 'CRITICAL' }  export enum UserRole {   USER = 'USER',   TECHNICIAN = 'TECHNICIAN',   ADMIN = 'ADMIN',   SUPER_ADMIN = 'SUPER_ADMIN' }  export enum WorkOrderStatus {   PENDING = 'PENDING',   ASSIGNED = 'ASSIGNED',   IN_PROGRESS = 'IN_PROGRESS',   COMPLETED = 'COMPLETED',   CANCELLED = 'CANCELLED' }  export enum WorkOrderPriority {   LOW = 'LOW',   MEDIUM = 'MEDIUM',   HIGH = 'HIGH',   CRITICAL = 'CRITICAL' }  export enum AssetStatus {   operational = "Operational",   maintenance = "Under Maintenance",   outOfService = "Out of Service" }  export enum AssetType {  }  export interface Asset {   id: string;   tenantId: string;   name: string;   location: string;   createdAt: string | string;   deletedAt: string | null | string;   updatedAt: string | string;    status: AssetStatus;   type: AssetType;  }  export interface Call {   id: string;   tenantId: string;   assetId: string;   reportedById: string;   issue: string;   callTime: string | string;   createdAt: string | string;   updatedAt: string | string;   status: CallStatus | string;   deletedAt: string | null | string; }  export interface MaintenanceAsset {   maintenanceId: string;   assetId: string; }  export interface MaintenanceSchedule {   id: string;   tenantId: string;   description: string;   recurrence: any;   nextRun: string;   lastRun: string | null;   status: MaintenanceStatus;   priority: MaintenancePriority;   assignedToId: string | null;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface Part {   id: string;   name: string;   description: string | null;   quantity: number;   minStock: number;   tenantId: string;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface PartVendor {   partId: string;   vendorId: string;   cost: number | null; }  export interface TenantConfig {   id: string;   tenantId: string;   modules: any;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface Tenant {   id: string;   name: string;   subdomain: string;   parentId: string | null;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface User {   id: string;   tenantId: string | null;   email: string;   password: string;   createdAt: string;   deletedAt: string | null;   updatedAt: string;   role: UserRole; }  export interface Vendor {   id: string;   name: string;   contact: string | null;   email: string | null;   tenantId: string;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface WorkOrder {   id: string;   tenantId: string;   description: string;   status: WorkOrderStatus;   createdAt: string;   updatedAt: string | string;   assignedToId: string | null;   deletedAt: string | string | null;   dueDate: string | string | null;   priority: WorkOrderPriority; }  export interface WorkOrderAsset {   workOrderId: string;   assetId: string; }  export interface WorkOrderNote {   id: string;   workOrderId: string;   note: string;   createdById: string | null;   createdAt: string;   deletedAt: string | null; }  // 4. Helper Types export type AuthUserMeta = {   name: string,   tenant_id: string | "error";   role: UserRole | UserRole.USER;   subdomain: string | "error";   modules: Record<string, boolean> | [];  };  export interface DashboardData {   meta: AuthUserMeta;   assets: Asset[];   calls: Call[];   workOrders: WorkOrder[];   parts: Part[];   vendors: Vendor[]; }  export interface DynamicDashboardProps {   initialData: DashboardData; }  export type UserSignUp = {   email: string;   password: string;   metaData: Record<string, object>; };  export type PaginatedResult<T> = {   data: T[];   page: number;   pageSize: number;   totalCount: number; }; /* end: ./src\lib\types.ts *//* start: ./src\lib\utils.ts*/ import { clsx, type ClassValue } from "clsx" import { twMerge } from "tailwind-merge"  export function cn(...inputs: ClassValue[]) {   return twMerge(clsx(inputs)) }  // Define a type for the transformed data type TransformedData<T> = T extends object   ? {       [K in keyof T as K extends string         ? K extends `${infer First}_${infer Rest}`           ? `${First}${Capitalize<Rest>}`           : K         : K]: T[K] extends string         ? T[K] extends `${number}-${number}-${number}T${string}`           ? Date           : T[K]         : TransformedData<T[K]>;     }   : T;  // Annotate the function with the type export const transformData = <T>(data: T): TransformedData<T> =>   !data || typeof data !== "object"     ? (data as TransformedData<T>) // Cast primitive types to the return type     : Object.fromEntries(         Object.entries(data).map(([key, value]) => [           key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),           typeof value === "string" && /\d{4}-\d{2}-\d{2}T/.test(value)             ? new Date(value)             : transformData(value),         ])       ) as TransformedData<T>; // Cast the result to the expected type /* end: ./src\lib\utils.ts *//* start: ./src\middleware.ts*/ import { NextResponse, type NextRequest } from 'next/server' import { updateSession } from '@/utils/supabase/middleware'  export async function middleware(request: NextRequest) {   if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY) {     console.error('Supabase env vars missing!')     return NextResponse.error();   }    return await updateSession(request) }  export const config = {   matcher: [     /*      * Match all request paths except for the ones starting with:      * - _next/static (static files)      * - _next/image (image optimization files)      * - favicon.ico (favicon file)      * Feel free to modify this pattern to include more paths.      */     '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',   ] }  /* end: ./src\middleware.ts *//* start: ./src\utils\supabase\client.ts*/ // src\utils\supabase\client.ts "use client"; import { createBrowserClient } from "@supabase/ssr";  export const supabase = createBrowserClient(   process.env.NEXT_PUBLIC_SUPABASE_URL!,   process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,   {     cookies: {       getAll() {         if (typeof document === "undefined") return []; // Return empty array during SSR         return document.cookie.split("; ").map((cookie) => {           const [name, value] = cookie.split("=");           return { name, value: value || "" };         });       },       setAll(cookiesToSet) {         if (typeof document === "undefined") return; // No-op during SSR         cookiesToSet.forEach(({ name, value, options }) => {           const cookieOptions = Object.entries(options || {})             .map(([k, v]) => `${k}=${v}`)             .join("; ");           document.cookie = `${name}=${value}; ${cookieOptions}`;         });       },     },     auth: {       autoRefreshToken: true,       persistSession: true,       detectSessionInUrl: true,     },     global: {       headers: { "x-App-Target": "RepairRadar" },     },   } ); /* end: ./src\utils\supabase\client.ts *//* start: ./src\utils\supabase\middleware.ts*/ import { AuthUserMeta } from '@/lib/types' import { createServerClient } from '@supabase/ssr' import { User } from '@supabase/supabase-js' import { redirect } from 'next/dist/server/api-utils' import { INTERNALS } from 'next/dist/server/web/spec-extension/request' import { NextRequest, NextResponse } from 'next/server'  export async function updateSession(request: NextRequest) {   let supabaseResponse = NextResponse.next({     request,   })    const supabase = createServerClient(     process.env.NEXT_PUBLIC_SUPABASE_URL!,     process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,     {       cookies: {         getAll() {           return request.cookies.getAll()         },         setAll(cookiesToSet) {           cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))           supabaseResponse = NextResponse.next({             request,           })           cookiesToSet.forEach(({ name, value, options }) =>             supabaseResponse.cookies.set(name, value, options)           )         },       },     }   )    // Do not run code between createServerClient and   // supabase.auth.getUser(). A simple mistake could make it very hard to debug   // issues with users being randomly logged out.    // IMPORTANT: DO NOT REMOVE auth.getUser()    const {     data: { user },   } = await supabase.auth.getUser()   if (!user && !request.nextUrl.pathname.startsWith('/login') && !request.nextUrl.pathname.startsWith('/auth')) {     const url = request.nextUrl.clone()     url.pathname = '/login'      return NextResponse.redirect(url)     // no user, potentially respond by redirecting the user to the login page   }    // IMPORTANT: You *must* return the supabaseResponse object as it is.   // If you're creating a new response object with NextResponse.next() make sure to:   // 1. Pass the request in it, like so:   //    const myNewResponse = NextResponse.next({ request })   // 2. Copy over the cookies, like so:   //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())   // 3. Change the myNewResponse object to fit your needs, but avoid changing   //    the cookies!   // 4. Finally:   //    return myNewResponse   // If this is not done, you may be causing the browser and server to go out   // of sync and terminate the user's session prematurely!    const data = user?.user_metadata as Record<string, any>   if((!data || !data["profile"]) && !request.nextUrl.pathname.startsWith("/login")){     const url = request.nextUrl.clone();     url.pathname = `/error?message=${'No organization found. Please contact supervisor.'}`;     supabaseResponse = NextResponse.redirect(url);   }    return supabaseResponse }    /* end: ./src\utils\supabase\middleware.ts *//* start: ./src\utils\supabase\server.ts*/ import { createServerClient } from '@supabase/ssr' import { cookies } from 'next/headers'  export async function createClient() {   const cookieStore = await cookies()   return createServerClient(     process.env.NEXT_PUBLIC_SUPABASE_URL!,     process.env.NEXT_PUBLIC_SUPABASE_SERVICE_ROLE_KEY!,     {       cookies: {         getAll() {           return cookieStore.getAll()         },         setAll(cookiesToSet) {           try {             cookiesToSet.forEach(({ name, value, options }) =>               cookieStore.set(name, value, options)             )           } catch {             // The `setAll` method was called from a Server Component.             // This can be ignored if you have middleware refreshing             // user sessions.           }         },       },     }   ) }  /* end: ./src\utils\supabase\server.ts */