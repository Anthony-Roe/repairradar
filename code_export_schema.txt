/* start: E:\Dev\websites\repairradar\next-env.d.ts*/ /// <reference types="next" /> /// <reference types="next/image-types/global" />  // NOTE: This file should not be edited // see https://nextjs.org/docs/app/api-reference/config/typescript for more information.  /* end: E:\Dev\websites\repairradar\next-env.d.ts *//* start: E:\Dev\websites\repairradar\next.config.ts*/ /** @type {import('next').NextConfig} */ const nextConfig = {   reactStrictMode: true };  export default nextConfig;  /* end: E:\Dev\websites\repairradar\next.config.ts *//* start: E:\Dev\websites\repairradar\prisma\schema.prisma*/ // This is your Prisma schema file, // learn more about it in the docs: https://pris.ly/d/prisma-schema  generator client {   provider = "prisma-client-js" }  datasource db {   provider = "postgresql"   url      = env("DATABASE_URL") }  enum AssetStatus {   OPERATIONAL   MAINTENANCE   OUT_OF_SERVICE   DECOMMISSIONED }  enum CallPriority {   LOW   MEDIUM   HIGH   CRITICAL }  enum CallStatus {   OPEN   IN_PROGRESS   ON_HOLD   CLOSED }  enum IndustryType {   MANUFACTURING   HEALTHCARE   FACILITY   LABORATORY   ENERGY   TRANSPORTATION   OTHER }  enum MaintenanceStatus {   SCHEDULED   IN_PROGRESS   COMPLETED   OVERDUE   CANCELLED }  enum MaintenanceTrigger {   TIME_BASED   METER_BASED }  enum UserRole {   TECHNICIAN   SUPERVISOR   MANAGER   ADMIN   SUPER_ADMIN }  enum WorkOrderStatus {   PENDING   IN_PROGRESS   ON_HOLD   COMPLETED   CANCELLED }  model Tenant {   id          String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   name        String   subdomain   String                @unique   parent      Tenant?               @relation("TenantParent", fields: [parentId], references: [id])   parentId    String?               @db.Uuid   settings    TenantSettings?   users       User[]   categories  AssetCategory[]   assetTypes  AssetType[]   assets      Asset[]   meters      Meter[]   maintenance MaintenanceSchedule[]   workOrders  WorkOrder[]   parts       Part[]   vendors     Vendor[]   incidents   Incident[]   children    Tenant[]              @relation("TenantParent")   createdAt   DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt   DateTime              @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt   DateTime?             @map("deleted_at") @db.Timestamptz(6)    @@map("tenants") }  model TenantSettings {   tenant    Tenant   @relation(fields: [tenantId], references: [id])   tenantId  String   @id @db.Uuid   config    Json     @default("{}")   createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt DateTime @default(now()) @map("updated_at") @db.Timestamptz(6)    @@map("tenant_settings") }  model User {   id           String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant       Tenant                  @relation(fields: [tenantId], references: [id])   tenantId     String                  @db.Uuid   employeeId        String                  @unique   email        String                  @unique   passwordHash String                  @map("password_hash")   role         UserRole   firstName    String?                 @map("first_name")   lastName     String?                 @map("last_name")   assignments  MaintenanceAssignment[]   workOrders   WorkOrderAssignment[]   labor        WorkOrderLabor[]   incidents    Incident[]   createdAt    DateTime                @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt    DateTime                @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt    DateTime?               @map("deleted_at") @db.Timestamptz(6)   WorkOrderLog WorkOrderLog[]    @@unique([tenantId, employeeId, email])   @@map("users") }  model AssetCategory {   id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant      Tenant       @relation(fields: [tenantId], references: [id])   tenantId    String       @db.Uuid   name        String   industry    IndustryType   description String?   metadata    Json         @default("{}")   assetTypes  AssetType[]   createdAt   DateTime     @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt   DateTime     @default(now()) @map("updated_at") @db.Timestamptz(6)    @@unique([tenantId, name])   @@map("asset_categories") }  model AssetType {   id                   String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant               Tenant         @relation(fields: [tenantId], references: [id])   tenantId             String         @db.Uuid   category             AssetCategory? @relation(fields: [categoryId], references: [id])   categoryId           String?        @db.Uuid   name                 String   description          String?   expectedLifespan     Int?           @map("expected_lifespan")   maintenanceFrequency Int?           @map("maintenance_frequency")   criticality          Int?   customFields         Json           @default("{}") @map("custom_fields")   assets               Asset[]   createdAt            DateTime       @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt            DateTime       @default(now()) @map("updated_at") @db.Timestamptz(6)    @@unique([tenantId, name])   @@map("asset_types") }  model Asset {   id                  String                           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant              Tenant                           @relation(fields: [tenantId], references: [id])   tenantId            String                           @db.Uuid   assetType           AssetType?                       @relation(fields: [assetTypeId], references: [id])   assetTypeId         String?                          @db.Uuid   name                String   location            String?   status              AssetStatus                      @default(OPERATIONAL)   serialNumber        String?                          @unique @map("serial_number")   purchaseDate        DateTime?                        @map("purchase_date") @db.Date   lastMaintenanceDate DateTime?                        @map("last_maintenance_date") @db.Timestamptz(6)   metadata            Json                             @default("{}")   assetMeters         AssetMeter[]   maintenance         MaintenanceAssets[]   workOrders          WorkOrderAssets[]   incidents           Incident[]   createdAt           DateTime                         @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt           DateTime                         @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt           DateTime?                        @map("deleted_at") @db.Timestamptz(6)    @@map("assets") }  model Meter {   id          String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant      Tenant                @relation(fields: [tenantId], references: [id])   tenantId    String                @db.Uuid   name        String   unit        String   assetMeters AssetMeter[]   maintenance MaintenanceSchedule[]   createdAt   DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt   DateTime              @default(now()) @map("updated_at") @db.Timestamptz(6)    @@map("meters") }  model AssetMeter {   id             String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   asset          Asset          @relation(fields: [assetId], references: [id])   assetId        String         @db.Uuid   meter          Meter          @relation(fields: [meterId], references: [id])   meterId        String         @db.Uuid   initialReading Decimal        @default(0) @map("initial_reading") @db.Decimal(15, 2)   readings       MeterReading[]   createdAt      DateTime       @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt      DateTime       @default(now()) @map("updated_at") @db.Timestamptz(6)    @@unique([assetId, meterId])   @@map("asset_meters") }  model MeterReading {   id           String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   assetMeter   AssetMeter @relation(fields: [assetMeterId], references: [id])   assetMeterId String     @db.Uuid   readingValue Decimal    @map("reading_value") @db.Decimal(15, 2)   readingDate  DateTime   @default(now()) @map("reading_date") @db.Timestamptz(6)   createdAt    DateTime   @default(now()) @map("created_at") @db.Timestamptz(6)    @@map("meter_readings") }  model MaintenanceSchedule {   id             String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant         Tenant                  @relation(fields: [tenantId], references: [id])   tenantId       String                  @db.Uuid   description    String   triggerType    MaintenanceTrigger      @default(TIME_BASED) @map("trigger_type")   recurrence     Json?   meter          Meter?                  @relation(fields: [meterId], references: [id])   meterId        String?                 @db.Uuid   thresholdValue Decimal?                @map("threshold_value") @db.Decimal(15, 2)   nextRun        DateTime?               @map("next_run") @db.Timestamptz(6)   lastRun        DateTime?               @map("last_run") @db.Timestamptz(6)   status         MaintenanceStatus       @default(SCHEDULED)   priority       CallPriority            @default(MEDIUM)   assignments    MaintenanceAssignment[]   assets         MaintenanceAssets[]   workOrders     WorkOrder[]   createdAt      DateTime                @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt      DateTime                @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt      DateTime?               @map("deleted_at") @db.Timestamptz(6)    @@map("maintenance_schedules") }  model MaintenanceAssignment {   maintenance   MaintenanceSchedule @relation(fields: [maintenanceId], references: [id])   maintenanceId String              @db.Uuid   user          User                @relation(fields: [userId], references: [id])   userId        String              @db.Uuid    @@id([maintenanceId, userId])   @@map("maintenance_assignments") }  model MaintenanceAssets {   maintenance   MaintenanceSchedule @relation(fields: [maintenanceId], references: [id])   maintenanceId String              @db.Uuid   asset         Asset               @relation(fields: [assetId], references: [id])   assetId       String              @db.Uuid    @@id([maintenanceId, assetId])   @@map("maintenance_assets") }  model WorkOrder {   id            String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant        Tenant                @relation(fields: [tenantId], references: [id])   tenantId      String                @db.Uuid   maintenance   MaintenanceSchedule?  @relation(fields: [maintenanceId], references: [id])   maintenanceId String?               @db.Uuid   description   String   status        WorkOrderStatus       @default(PENDING)   priority      CallPriority          @default(MEDIUM)   dueDate       DateTime?             @map("due_date") @db.Timestamptz(6)   startedAt     DateTime?             @map("started_at") @db.Timestamptz(6)   completedAt   DateTime?             @map("completed_at") @db.Timestamptz(6)   assignments   WorkOrderAssignment[]   assets        WorkOrderAssets[]   parts         WorkOrderParts[]   labor         WorkOrderLabor[]   logs          WorkOrderLog[]   createdAt     DateTime              @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt     DateTime              @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt     DateTime?             @map("deleted_at") @db.Timestamptz(6)    @@map("work_orders") }  model WorkOrderAssignment {   workOrder   WorkOrder @relation(fields: [workOrderId], references: [id])   workOrderId String    @db.Uuid   user        User      @relation(fields: [userId], references: [id])   userId      String    @db.Uuid    @@id([workOrderId, userId])   @@map("work_order_assignments") }  model WorkOrderAssets {   workOrder   WorkOrder @relation(fields: [workOrderId], references: [id])   workOrderId String    @db.Uuid   asset       Asset     @relation(fields: [assetId], references: [id])   assetId     String    @db.Uuid    @@id([workOrderId, assetId])   @@map("work_order_assets") }  model Part {   id          String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant      Tenant           @relation(fields: [tenantId], references: [id])   tenantId    String           @db.Uuid   name        String   partNumber  String?          @unique @map("part_number")   description String?   quantity    Int              @default(0)   minStock    Int              @default(0) @map("min_stock")   unitCost    Decimal?         @map("unit_cost") @db.Decimal(10, 2)   vendors     PartVendor[]   workOrders  WorkOrderParts[]   createdAt   DateTime         @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt   DateTime         @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt   DateTime?        @map("deleted_at") @db.Timestamptz(6)    @@map("parts") }  model WorkOrderParts {   workOrder    WorkOrder @relation(fields: [workOrderId], references: [id])   workOrderId  String    @db.Uuid   part         Part      @relation(fields: [partId], references: [id])   partId       String    @db.Uuid   quantityUsed Int       @map("quantity_used")    @@id([workOrderId, partId])   @@map("work_order_parts") }  model Vendor {   id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant      Tenant       @relation(fields: [tenantId], references: [id])   tenantId    String       @db.Uuid   name        String   contactInfo Json?        @map("contact_info")   parts       PartVendor[]   createdAt   DateTime     @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt   DateTime     @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt   DateTime?    @map("deleted_at") @db.Timestamptz(6)    @@map("vendors") }  model PartVendor {   part     Part    @relation(fields: [partId], references: [id])   partId   String  @db.Uuid   vendor   Vendor  @relation(fields: [vendorId], references: [id])   vendorId String  @db.Uuid   cost     Decimal @db.Decimal(10, 2)   leadTime Int?    @map("lead_time")    @@id([partId, vendorId])   @@map("part_vendors") }  model WorkOrderLabor {   id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   workOrder       WorkOrder @relation(fields: [workOrderId], references: [id])   workOrderId     String    @db.Uuid   user            User?     @relation(fields: [userId], references: [id])   userId          String?   @db.Uuid   hours           Decimal   @db.Decimal(5, 2)   taskDescription String?   @map("task_description")   createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)    @@map("work_order_labor") }  model Incident {   id           String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   tenant       Tenant       @relation(fields: [tenantId], references: [id])   tenantId     String       @db.Uuid   asset        Asset?       @relation(fields: [assetId], references: [id])   assetId      String?      @db.Uuid   reportedBy   User?        @relation(fields: [reportedById], references: [id])   reportedById String?      @db.Uuid   description  String   status       CallStatus   @default(OPEN)   priority     CallPriority @default(MEDIUM)   reportedAt   DateTime     @default(now()) @map("reported_at") @db.Timestamptz(6)   resolvedAt   DateTime?    @map("resolved_at") @db.Timestamptz(6)   createdAt    DateTime     @default(now()) @map("created_at") @db.Timestamptz(6)   updatedAt    DateTime     @default(now()) @map("updated_at") @db.Timestamptz(6)   deletedAt    DateTime?    @map("deleted_at") @db.Timestamptz(6)    @@map("incidents") }  model WorkOrderLog {   id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid   workOrder   WorkOrder @relation(fields: [workOrderId], references: [id])   workOrderId String    @db.Uuid   user        User?     @relation(fields: [userId], references: [id])   userId      String?   @db.Uuid   action      String   details     Json?   createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)    @@map("work_order_logs") }  /* end: E:\Dev\websites\repairradar\prisma\schema.prisma *//* start: E:\Dev\websites\repairradar\src\app\api\dashboard\route.ts*/ // src/app/api/dashboard/route.ts import { NextResponse } from 'next/server' import {prisma} from '@/lib/prisma' import { auth } from '@/auth'  export async function GET() {   const session = await auth()      if (!session?.user?.tenant?.id) {     return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })   }    const data = await prisma.$transaction([     prisma.asset.findMany({ where: { tenantId: session.user.tenant.id } }),     prisma.incident.findMany({ where: { tenantId: session.user.tenant.id } }),     prisma.workOrder.findMany({ where: { tenantId: session.user.tenant.id } }),     prisma.part.findMany({ where: { tenantId: session.user.tenant.id } }),     prisma.vendor.findMany({ where: { tenantId: session.user.tenant.id } })   ])    return NextResponse.json({     meta: session.user,     assets: data[0],     calls: data[1],     workOrders: data[2],     parts: data[3],     vendors: data[4]   }) } /* end: E:\Dev\websites\repairradar\src\app\api\dashboard\route.ts *//* start: E:\Dev\websites\repairradar\src\app\auth\confirm\route.ts*/ import { type EmailOtpType } from '@supabase/supabase-js' import { type NextRequest } from 'next/server'  import { createClient } from '@/utils/supabase/server' import { redirect } from 'next/navigation'  export async function GET(request: NextRequest) {   const { searchParams } = new URL(request.url)   const token_hash = searchParams.get('token_hash')   const type = searchParams.get('type') as EmailOtpType | null   const next = searchParams.get('next') ?? '/'    if (token_hash && type) {     const supabase = await createClient()      const { error } = await supabase.auth.verifyOtp({       type,       token_hash,     })      if (!error) {       // redirect user to specified redirect URL or root of app       redirect(next)     }    }    // redirect the user to an error page with some instructions   redirect('/error') } /* end: E:\Dev\websites\repairradar\src\app\auth\confirm\route.ts *//* start: E:\Dev\websites\repairradar\src\app\dashboard\actions.ts*/ // app/dashboard/actions.ts "use server"; import { Asset, CallPriority, WorkOrder, CallStatus, Incident } from "@prisma/client"; import { revalidatePath } from "next/cache"; import { redirect } from "next/navigation"; import {prisma} from "@/lib/prisma";  // Helper to get current user with tenant async function getCurrentUser() {   const user = await prisma.user.findUnique({     where: { id: "CURRENT_USER_ID" }, // Replace with your auth logic     include: { tenant: true }   });    if (!user || !user.tenant) redirect("/login");   return user; }  // Dashboard Data Fetching export async function fetchDashboardData() {   const user = await getCurrentUser();    const [     assets,     calls,     workOrders,     parts,     vendors   ] = await Promise.all([     prisma.asset.findMany({ where: { tenantId: user.tenantId } }),     prisma.incident.findMany({ where: { tenantId: user.tenantId } }),     prisma.workOrder.findMany({ where: { tenantId: user.tenantId } }),     prisma.part.findMany({ where: { tenantId: user.tenantId } }),     prisma.vendor.findMany({ where: { tenantId: user.tenantId } }),   ]);    return {      meta: user,     assets,      calls,      workOrders,      parts,      vendors    }; }  // Call Actions export async function endCall(callId: string) {   try {     await prisma.incident.update({       where: { id: callId },       data: { status: CallStatus.CLOSED }     });     revalidatePath("/dashboard");     return { success: true };   } catch (error) {     console.error("Error ending call:", error);     return { error: "Failed to update call" };   } }  export async function createWorkOrder(   assetIds: string[],   description: string,   priority: CallPriority = CallPriority.LOW ) {   const user = await getCurrentUser();    // Validation   if (!description || description.length < 10) {     return { error: "Description must be at least 10 characters" };   }    try {     const workOrder = await prisma.workOrder.create({       data: {         tenantId: user.tenantId,         description,         priority,         assets: {           create: assetIds.map(assetId => ({             asset: { connect: { id: assetId } }           }))         }       },       include: { assets: { include: { asset: true } } }     });      await prisma.workOrderLog.create({       data: {         workOrderId: workOrder.id,         userId: user.id,         action: "CREATED",         details: { message: `Created by ${user.firstName} ${user.lastName}` }       }     });      revalidatePath("/dashboard");     return {        data: {         ...workOrder,         assets: workOrder.assets.map(wa => wa.asset) // Flatten the response       }      };   } catch (error) {     console.error("Error creating work order:", error);     return { error: "Failed to create work order" };   } }  // Asset Actions export async function createAsset(input: { name: string; location: string }) {   const user = await getCurrentUser();    try {     const asset = await prisma.asset.create({       data: {         tenantId: user.tenantId,         ...input       }     });     revalidatePath("/dashboard");     return { data: asset };   } catch (error) {     console.error("Error creating asset:", error);     return { error: "Failed to create asset" };   } }  // Call Creation export async function createCall(input: { assetId: string; description: string }) {   const user = await getCurrentUser();    try {     const call = await prisma.incident.create({       data: {         tenantId: user.tenantId,         ...input,         status: CallStatus.OPEN       }     });     revalidatePath("/dashboard");     return { data: call };   } catch (error) {     console.error("Error creating call:", error);     return { error: "Failed to create call" };   } } /* end: E:\Dev\websites\repairradar\src\app\dashboard\actions.ts *//* start: E:\Dev\websites\repairradar\src\app\login\actions.ts*/ 'use server';  import { revalidatePath } from 'next/cache'; import { redirect } from 'next/navigation'; import { createClient } from '@/utils/supabase/server'; import { z } from 'zod';  const FormSchema = z.object({   email: z.string().email('Invalid email address'),   password: z.string().min(6, 'Password must be at least 6 characters') });  export type FormState = {   errors?: {     email?: string[];     password?: string[];   };   message: string; };  export async function signIn(   prevState: FormState,   formData: FormData ): Promise<FormState> {   const supabase = await createClient();      const validatedFields = FormSchema.safeParse({     email: formData.get('email'),     password: formData.get('password')   });    if (!validatedFields.success) {     return {       errors: validatedFields.error.flatten().fieldErrors,       message: 'Missing or invalid fields'     };   }    const { email, password } = validatedFields.data;    const { error } = await supabase.auth.signInWithPassword({ email, password });    if (error) {     return {        message: error.message || 'Authentication failed'      };   }    revalidatePath('/', 'layout');   redirect('/dashboard');   return { message: 'Success' }; // This line won't be reached due to redirect } /* end: E:\Dev\websites\repairradar\src\app\login\actions.ts *//* start: E:\Dev\websites\repairradar\src\auth.ts*/ // auth.ts import NextAuth from "next-auth"; import Credentials from "next-auth/providers/credentials"; import { prisma } from "@/lib/prisma"; import { verifyPassword } from "@/lib/auth-utils"; import { CustomPrismaAdapter } from "@/lib/auth-adapter"; import { UserRole } from "@prisma/client"; export { auth as middleware } from "@/auth";  export const { handlers, auth, signIn, signOut } = NextAuth({   adapter: CustomPrismaAdapter(prisma),   providers: [     Credentials({       name: "Credentials",       credentials: {         employeeId: { label: "Employee ID", type: "text" },         password: { label: "Password", type: "password" }       },       async authorize(credentials) {         if (!credentials?.employeeId || !credentials?.password) return null;                  const user = await prisma.user.findUnique({           where: { employeeId: credentials.employeeId as string },           include: { tenant: true }         });          if (!user || !(await verifyPassword(credentials.password as string, user.passwordHash))) {           return null;         }          return {           id: user.id,           email: user.email,           name: [user.firstName, user.lastName].filter(Boolean).join(" ") || null,           firstName: user.firstName || undefined,           lastName: user.lastName || undefined,           role: user.role,           employeeId: user.employeeId,           tenantId: user.tenantId,           tenant: user.tenant ? {             id: user.tenant.id,             name: user.tenant.name,             subdomain: user.tenant.subdomain           } : undefined         };       }     })   ],   session: { strategy: "jwt" },   callbacks: {     async jwt({ token, user }) {       if (user) {         token.id = user.id;         token.employeeId = user.employeeId;         token.role = user.role;         token.tenant = user.tenant;         token.tenantId = user.tenantId;       }       return token;     },     async session({ session, token }) {       if (token) {         session.user.id = token.id as string;         session.user.employeeId = token.employeeId as string;         session.user.role = token.role as UserRole;         session.user.tenant = token.tenant as {           id: string;           name: string;           subdomain: string;         };         session.user.name = token.name as string | null;         session.user.email = token.email as string | null;       }       return session;     }   } });  /* end: E:\Dev\websites\repairradar\src\auth.ts *//* start: E:\Dev\websites\repairradar\src\components\ui\index.ts*/ export * from "./button"; export * from "./card"; export * from "./input"; export * from "./dialog"; export * from "./alert"; export * from "./avatar"; export * from "./badge"; export * from "./checkbox"; export * from "./dropdown-menu"; export * from "./form"; export * from "./popover"; export * from "./progress"; export * from "./radio-group"; export * from "./select"; export * from "./slider"; export * from "./switch"; export * from "./table"; export * from "./tabs"; export * from "./textarea"; export * from "./tooltip";  /* end: E:\Dev\websites\repairradar\src\components\ui\index.ts *//* start: E:\Dev\websites\repairradar\src\lib\auth-adapter.ts*/ // lib/auth-prisma-adapter.ts import type { Adapter } from "next-auth/adapters"; import { PrismaClient } from "@prisma/client";  export function CustomPrismaAdapter(prisma: PrismaClient): Adapter {   return {     async createUser(userData: any) {       const user = await prisma.user.create({         data: {           email: userData.email || null,           firstName: userData.firstName || null,           lastName: userData.lastName || null,           passwordHash: userData.passwordHash || '', // Handle password hashing elsewhere           employeeId: userData.employeeId || '', // Generate if needed           role: userData.role || 'TECHNICIAN', // Default role           tenantId: userData.tenantId || '', // Required in your schema         },       });        return {         id: user.id,         email: user.email,         name: [user.firstName, user.lastName].filter(Boolean).join(" ") || null,         firstName: user.firstName || undefined,         lastName: user.lastName || undefined,         role: user.role,         employeeId: user.employeeId,         tenantId: user.tenantId,         emailVerified: null, // Required by NextAuth       };     },      async getUser(id) {       const user = await prisma.user.findUnique({         where: { id },         include: { tenant: true }       });       return user ? {         id: user.id,         email: user.email,         name: [user.firstName, user.lastName].filter(Boolean).join(" ") || null,         firstName: user.firstName || undefined,         lastName: user.lastName || undefined,         role: user.role,         employeeId: user.employeeId,         tenantId: user.tenantId,         emailVerified: null       } : null;     },      async getUserByEmail(email) {       const user = await prisma.user.findUnique({         where: { email },         include: { tenant: true }       });       return user ? {         id: user.id,         email: user.email,         name: [user.firstName, user.lastName].filter(Boolean).join(" ") || null,         firstName: user.firstName || undefined,         lastName: user.lastName || undefined,         role: user.role,         employeeId: user.employeeId,         tenantId: user.tenantId,         emailVerified: null       } : null;     },      async getUserByAccount({ providerAccountId, provider }) {       const account = await prisma.account.findUnique({         where: {           provider_providerAccountId: {             provider,             providerAccountId,           },         },         include: {           user: {             include: { tenant: true }           },         },       });       return account?.user ? {         id: account.user.id,         email: account.user.email,         name: [account.user.firstName, account.user.lastName].filter(Boolean).join(" ") || null,         firstName: account.user.firstName || undefined,         lastName: account.user.lastName || undefined,         role: account.user.role,         employeeId: account.user.employeeId,         tenantId: account.user.tenantId,         emailVerified: null       } : null;     },      async updateUser(user) {       const updatedUser = await prisma.user.update({         where: { id: user.id },         data: {           email: user.email,           firstName: user.firstName,           lastName: user.lastName,           role: user.role,           employeeId: user.employeeId,           tenantId: user.tenantId,         },         include: { tenant: true }       });        return {         id: updatedUser.id,         email: updatedUser.email,         name: [updatedUser.firstName, updatedUser.lastName].filter(Boolean).join(" ") || null,         firstName: updatedUser.firstName || undefined,         lastName: updatedUser.lastName || undefined,         role: updatedUser.role,         employeeId: updatedUser.employeeId,         tenantId: updatedUser.tenantId,         emailVerified: null       };     },      async deleteUser(userId) {       await prisma.user.delete({ where: { id: userId } });     },      async linkAccount(account) {       await prisma.account.create({         data: {           userId: account.userId,           type: account.type,           provider: account.provider,           providerAccountId: account.providerAccountId,           refresh_token: account.refresh_token,           access_token: account.access_token,           expires_at: account.expires_at,           token_type: account.token_type,           scope: account.scope,           id_token: account.id_token,           session_state: account.session_state,         },       });     },      async unlinkAccount({ providerAccountId, provider }) {       await prisma.account.delete({         where: {           provider_providerAccountId: {             provider,             providerAccountId,           },         },       });     },      async createSession({ sessionToken, userId, expires }) {       const session = await prisma.session.create({         data: {           sessionToken,           userId,           expires,         },       });       return session;     },      async getSessionAndUser(sessionToken) {       const session = await prisma.session.findUnique({         where: { sessionToken },         include: {           user: {             include: { tenant: true }           },         },       });        if (!session) return null;        const { user, ...sessionData } = session;        return {         session: sessionData,         user: {           id: user.id,           email: user.email,           name: [user.firstName, user.lastName].filter(Boolean).join(" ") || null,           firstName: user.firstName || undefined,           lastName: user.lastName || undefined,           role: user.role,           employeeId: user.employeeId,           tenantId: user.tenantId,           emailVerified: null         },       };     },      async updateSession({ sessionToken, expires, userId }) {       const session = await prisma.session.update({         where: { sessionToken },         data: { expires, userId },       });       return session;     },      async deleteSession(sessionToken) {       await prisma.session.delete({ where: { sessionToken } });     },      async createVerificationToken({ identifier, expires, token }) {       const verificationToken = await prisma.verificationToken.create({         data: {           identifier,           token,           expires,         },       });       return verificationToken;     },      async useVerificationToken({ identifier, token }) {       try {         const verificationToken = await prisma.verificationToken.delete({           where: {             identifier_token: {               identifier,               token,             },           },         });         return verificationToken;       } catch (error) {         return null;       }     },   }; } /* end: E:\Dev\websites\repairradar\src\lib\auth-adapter.ts *//* start: E:\Dev\websites\repairradar\src\lib\auth-utils.ts*/ // lib/auth-utils.ts import { compare } from 'bcryptjs'; import { cookies } from 'next/headers'; import { prisma } from './prisma';  /**  * Verifies a plain text password against a hashed password  * @param plainPassword The plain text password to verify  * @param hashedPassword The hashed password to compare against  * @returns Promise<boolean> True if passwords match, false otherwise  */ export async function verifyPassword(   plainPassword: string,   hashedPassword: string ): Promise<boolean> {   try {     return await compare(plainPassword, hashedPassword);   } catch (error) {     console.error('Error verifying password:', error);     return false;   } }  export async function verifySession(cookieStore: ReturnType<typeof cookies>) {   const sessionToken = cookieStore.get('session-token')?.value   if (!sessionToken) return null    const session = await prisma.session.findUnique({     where: { sessionToken },     include: { user: true }   })    if (!session || new Date() > session.expires) return null    return {     user: {       id: session.user.id,       email: session.user.email,       role: session.user.role,       // Add other user fields as needed     }   } }  /* end: E:\Dev\websites\repairradar\src\lib\auth-utils.ts *//* start: E:\Dev\websites\repairradar\src\lib\middleware.ts*/ // utils/prisma/middleware.ts import { NextResponse, type NextRequest } from 'next/server' import { prisma } from '@/lib/prisma' import { verifySession } from '@/lib/auth' // Your custom auth utility  export async function updateSession(request: NextRequest) {   let response = NextResponse.next({     request,   })    // Verify session from cookies (replace with your auth system)   const session = await verifySession(request.cookies)    if (     !session?.user &&     !request.nextUrl.pathname.startsWith('/login') &&     !request.nextUrl.pathname.startsWith('/auth')   ) {     const url = request.nextUrl.clone()     url.pathname = '/login'     return NextResponse.redirect(url)   }    // If authenticated but trying to access auth pages   if (session?.user && request.nextUrl.pathname.startsWith('/auth')) {     const url = request.nextUrl.clone()     url.pathname = '/dashboard'     return NextResponse.redirect(url)   }    // Add user to request headers for server components   if (session?.user) {     const newHeaders = new Headers(request.headers)     newHeaders.set('x-user-id', session.user.id)     newHeaders.set('x-user-role', session.user.role)     response = NextResponse.next({       request: {         headers: newHeaders,       },     })   }    return response } /* end: E:\Dev\websites\repairradar\src\lib\middleware.ts *//* start: E:\Dev\websites\repairradar\src\lib\prisma.ts*/ // src/lib/prisma.ts import { PrismaClient } from '@prisma/client'  declare global {   var prisma: PrismaClient | undefined }  export const prisma = globalThis.prisma || new PrismaClient()  if (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma /* end: E:\Dev\websites\repairradar\src\lib\prisma.ts *//* start: E:\Dev\websites\repairradar\src\lib\session.ts*/ // lib/session.ts import { prisma } from './prisma' import { cookies } from 'next/headers' import { randomBytes } from 'crypto'  export async function createSession(userId: string) {   const sessionToken = randomBytes(32).toString('hex')   const expires = new Date()   expires.setDate(expires.getDate() + 30) // 30 days expiration    await prisma.session.create({     data: {       sessionToken,       userId,       expires,     },   })    cookies().set('session-token', sessionToken, {     expires,     httpOnly: true,     secure: process.env.NODE_ENV === 'production',     sameSite: 'lax',     path: '/',   }) }  export async function deleteSession() {   const sessionToken = cookies().get('session-token')?.value   if (!sessionToken) return    await prisma.session.delete({     where: { sessionToken }   })    cookies().delete('session-token') } /* end: E:\Dev\websites\repairradar\src\lib\session.ts *//* start: E:\Dev\websites\repairradar\src\lib\types.ts*/ export enum CallStatus {   OPEN = 'OPEN',   IN_PROGRESS = 'IN_PROGRESS',   COMPLETED = 'COMPLETED',   CLOSED = 'CLOSED' }  export enum MaintenanceStatus {   SCHEDULED = 'SCHEDULED',   IN_PROGRESS = 'IN_PROGRESS',   COMPLETED = 'COMPLETED',   OVERDUE = 'OVERDUE' }  export enum MaintenancePriority {   LOW = 'LOW',   MEDIUM = 'MEDIUM',   HIGH = 'HIGH',   CRITICAL = 'CRITICAL' }  export enum UserRole {   USER = 'USER',   TECHNICIAN = 'TECHNICIAN',   ADMIN = 'ADMIN',   SUPER_ADMIN = 'SUPER_ADMIN' }  export enum WorkOrderStatus {   PENDING = 'PENDING',   ASSIGNED = 'ASSIGNED',   IN_PROGRESS = 'IN_PROGRESS',   COMPLETED = 'COMPLETED',   CANCELLED = 'CANCELLED' }  export enum WorkOrderPriority {   LOW = 'LOW',   MEDIUM = 'MEDIUM',   HIGH = 'HIGH',   CRITICAL = 'CRITICAL' }  export enum AssetStatus {   operational = "Operational",   maintenance = "Under Maintenance",   outOfService = "Out of Service" }  export enum AssetType {  }  export interface Asset {   id: string;   tenantId: string;   name: string;   location: string;   createdAt: string | string;   deletedAt: string | null | string;   updatedAt: string | string;    status: AssetStatus;   type: AssetType;  }  export interface Call {   id: string;   tenantId: string;   assetId: string;   reportedById: string;   issue: string;   callTime: string | string;   createdAt: string | string;   updatedAt: string | string;   status: CallStatus | string;   deletedAt: string | null | string; }  export interface MaintenanceAsset {   maintenanceId: string;   assetId: string; }  export interface MaintenanceSchedule {   id: string;   tenantId: string;   description: string;   recurrence: any;   nextRun: string;   lastRun: string | null;   status: MaintenanceStatus;   priority: MaintenancePriority;   assignedToId: string | null;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface Part {   id: string;   name: string;   description: string | null;   quantity: number;   minStock: number;   tenantId: string;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface PartVendor {   partId: string;   vendorId: string;   cost: number | null; }  export interface TenantConfig {   id: string;   tenantId: string;   modules: any;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface Tenant {   id: string;   name: string;   subdomain: string;   parentId: string | null;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface User {   id: string;   tenantId: string | null;   email: string;   password: string;   createdAt: string;   deletedAt: string | null;   updatedAt: string;   role: UserRole; }  export interface Vendor {   id: string;   name: string;   contact: string | null;   email: string | null;   tenantId: string;   createdAt: string;   updatedAt: string;   deletedAt: string | null; }  export interface WorkOrder {   id: string;   tenantId: string;   description: string;   status: WorkOrderStatus;   createdAt: string;   updatedAt: string | string;   assignedToId: string | null;   deletedAt: string | string | null;   dueDate: string | string | null;   priority: WorkOrderPriority; }  export interface WorkOrderAsset {   workOrderId: string;   assetId: string; }  export interface WorkOrderNote {   id: string;   workOrderId: string;   note: string;   createdById: string | null;   createdAt: string;   deletedAt: string | null; }  // 4. Helper Types export type AuthUserMeta = {   name: string,   tenant_id: string | "error";   role: UserRole | UserRole.USER;   subdomain: string | "error";   modules: Record<string, boolean> | [];  };  export interface DashboardData {   meta: AuthUserMeta;   assets: Asset[];   calls: Call[];   workOrders: WorkOrder[];   parts: Part[];   vendors: Vendor[]; }  export interface DynamicDashboardProps {   initialData: DashboardData; }  export type UserSignUp = {   email: string;   password: string;   metaData: Record<string, object>; };  export type PaginatedResult<T> = {   data: T[];   page: number;   pageSize: number;   totalCount: number; }; /* end: E:\Dev\websites\repairradar\src\lib\types.ts *//* start: E:\Dev\websites\repairradar\src\lib\utils.ts*/ import { clsx, type ClassValue } from "clsx" import { twMerge } from "tailwind-merge"  export function cn(...inputs: ClassValue[]) {   return twMerge(clsx(inputs)) }  // Define a type for the transformed data type TransformedData<T> = T extends object   ? {       [K in keyof T as K extends string         ? K extends `${infer First}_${infer Rest}`           ? `${First}${Capitalize<Rest>}`           : K         : K]: T[K] extends string         ? T[K] extends `${number}-${number}-${number}T${string}`           ? Date           : T[K]         : TransformedData<T[K]>;     }   : T;  // Annotate the function with the type export const transformData = <T>(data: T): TransformedData<T> =>   !data || typeof data !== "object"     ? (data as TransformedData<T>) // Cast primitive types to the return type     : Object.fromEntries(         Object.entries(data).map(([key, value]) => [           key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase()),           typeof value === "string" && /\d{4}-\d{2}-\d{2}T/.test(value)             ? new Date(value)             : transformData(value),         ])       ) as TransformedData<T>; // Cast the result to the expected type /* end: E:\Dev\websites\repairradar\src\lib\utils.ts *//* start: E:\Dev\websites\repairradar\src\middleware.ts*/ // middleware.ts import { NextResponse, type NextRequest } from 'next/server' import { updateSession } from '@/lib/middleware'  export async function middleware(request: NextRequest) {   return await updateSession(request) }  export const config = {   matcher: [     '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',   ], } /* end: E:\Dev\websites\repairradar\src\middleware.ts *//* start: E:\Dev\websites\repairradar\src\types\next-auth.d.ts*/ // types/next-auth.d.ts import { UserRole } from "@prisma/client"; import "next-auth";  declare module "next/server" {     interface NextRequest {       auth?: {         user?: {           id: string;           employeeId: string;           role: UserRole;           tenant?: {             id: string;             name: string;             subdomain: string;           };         };       };     }   }    export function isAuthenticated(     req: NextRequest   ): req is AuthenticatedNextRequest {     return !!req.auth?.user;   }    export interface AuthenticatedNextRequest extends NextRequest {     auth: {       user: {         id: string;         employeeId: string;         role: UserRole;         tenant?: {           id: string;           name: string;           subdomain: string;         };       };     };   }  declare module "next-auth" {   interface User {     id: string;     email: string;     name: string | null;     firstName?: string;     lastName?: string;     role: UserRole;     employeeId: string;     tenantId: string;     tenant?: {       id: string;       name: string;       subdomain: string;     };   }    interface Session {     user: {       id: string;       email: string | null;       name: string | null;       firstName?: string;       lastName?: string;       role: UserRole;       employeeId: string;       tenantId: string;       tenant?: {         id: string;         name: string;         subdomain: string;       };     };   } }  declare module "@auth/core/adapters" {   interface AdapterUser extends User {} } /* end: E:\Dev\websites\repairradar\src\types\next-auth.d.ts */