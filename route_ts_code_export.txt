// File: E:\Dev\websites\repairradar\module_exports\dashboard_1742963705555\components\DashboardPage.tsx


import { useTenantData } from "@/shared/lib/hooks";
import { useassetsData } from "@/shared/modules/assets/hooks";
import { usecallsData } from "@/shared/modules/calls/hooks";
import { usepreventative-maintenanceData } from "@/shared/modules/preventative-maintenance/hooks";
import { usework-ordersData } from "@/shared/modules/work-orders/hooks";

export default function DashboardPage({ tenant }: { tenant: string }) {
  return (
    <div className="space-y-4">
      {/* Dashboard implementation - AI to complete */}
    </div>
  );
}

// File: E:\Dev\websites\repairradar\module_exports\dashboard_1742963705555\types.ts


export interface Dashboard {
  id: string;
  tenantId: string;
  assetsId?: string;
  callsId?: string;
  preventative-maintenanceId?: string;
  work-ordersId?: string;
  // AI to add additional fields based on research
}

// File: E:\Dev\websites\repairradar\next-auth.d.ts


import NextAuth from "next-auth";

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      email?: string | null;
      tenantId?: string | null;
      role?: string | null;
    };
  }

  interface User {
    id: string;
    email?: string | null;
    tenantId?: string | null;
    role?: string | null;
  }
}

// File: E:\Dev\websites\repairradar\next-env.d.ts


/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


// File: E:\Dev\websites\repairradar\next.config.ts


/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  allowedDevOrigins: ["http://admin.localhost:3000", "http://*.localhost:3000"],
  experimental: {
    nodeMiddleware: true, // Enables Node.js runtime for middleware
  },
};

export default nextConfig;

// File: E:\Dev\websites\repairradar\prisma\seed.ts


// prisma/seed.ts
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
  const adminUser = await prisma.user.upsert({
    where: { email: "super@admin.com" },
    update: { password: "admin123", role: "SUPER_ADMIN" },
    create: { email: "super@admin.com", password: "admin123", role: "SUPER_ADMIN" },
  });

  const plygem = await prisma.tenants.upsert({
    where: { subdomain: "plygem" },
    update: {},
    create: {
      name: "Plygem",
      subdomain: "plygem",
      config: { create: { modules: { calls: true, assets: true, "work-orders": true } } },
    },
  });

  const acme = await prisma.tenants.upsert({
    where: { subdomain: "acme" },
    update: {},
    create: {
      name: "Acme Corp",
      subdomain: "acme",
      config: { create: { modules: { calls: true, assets: false, "work-orders": true } } },
    },
  });

  // Clear old data
  await prisma.workOrderNote.deleteMany({ where: { workOrder: { tenantId: { in: [plygem.id, acme.id] } } } });
  await prisma.workOrderAsset.deleteMany({ where: { workOrder: { tenantId: { in: [plygem.id, acme.id] } } } });
  await prisma.workOrder.deleteMany({ where: { tenantId: { in: [plygem.id, acme.id] } } });
  await prisma.call.deleteMany({ where: { tenantId: { in: [plygem.id, acme.id] } } });
  await prisma.asset.deleteMany({ where: { tenantId: { in: [plygem.id, acme.id] } } });

  // Create assets
  const plygemAsset1 = await prisma.asset.create({
    data: { name: "Window Unit", tenantId: plygem.id, location: "Warehouse" },
  });
  const plygemAsset2 = await prisma.asset.create({
    data: { name: "Door Frame", tenantId: plygem.id, location: "Storefront" },
  });
  const acmeAsset = await prisma.asset.create({
    data: { name: "Machine A", tenantId: acme.id, location: "Factory" },
  });

  // Create calls
  await prisma.call.create({
    data: {
      issue: "Broken Window",
      status: "OPEN",
      tenantId: plygem.id,
      assetId: plygemAsset1.id,
      reportedById: adminUser.id,
    },
  });

  // Create work orders with multiple assets and notes
  await prisma.workOrder.create({
    data: {
      description: "Fix Door",
      status: "PENDING",
      tenantId: plygem.id,
      priority: "MEDIUM",
      assets: { create: [{ assetId: plygemAsset2.id }] },
      notes: { create: [{ note: "Check hinges", createdById: adminUser.id }] },
    },
  });

  await prisma.workOrder.create({
    data: {
      description: "Repair Machine",
      status: "IN_PROGRESS",
      tenantId: acme.id,
      priority: "HIGH",
      assets: { create: [{ assetId: acmeAsset.id }] },
      assignedToId: adminUser.id,
    },
  });

  console.log("Seeding completed successfully!");
}

main()
  .then(() => prisma.$disconnect())
  .catch((e) => {
    console.error(e);
    prisma.$disconnect();
    process.exit(1);
  });

// File: E:\Dev\websites\repairradar\scripts\exportCode.js


// generate-route-ts-code-export.js
const fs = require('fs');
const path = require('path');

// Configuration
const EXPORT_FILE = 'route_ts_code_export.txt';
const IGNORE_DIRS = new Set(['node_modules', '.next', '.git', 'dist', 'build']);
const IGNORE_FILES = new Set(['package-lock.json', 'yarn.lock', '.DS_Store']);
const TARGET_FILE_NAME = ''; // Only export route.ts files
const TARGET_EXTENSIONS = ['.ts', '.tsx', '.js']; // Supported extensions array

function generateExport() {
  try {
    console.log('ðŸ” Searching for .ts, .tsx, and .js files...');

    const exportContent = [];
    const rootPath = process.cwd();

    // Start scanning the directories
    scanDirectory(rootPath, exportContent);

    // Write all collected code to the export file
    fs.writeFileSync(EXPORT_FILE, exportContent.join('\n\n'));

    console.log(`âœ… Export generated: ${EXPORT_FILE}`);
    console.log('ðŸ“‹ All code from selected files has been exported.');

  } catch (error) {
    console.error('âŒ Failed to generate export:', error);
  }
}

function scanDirectory(currentPath, exportContent) {
  try {
    const items = fs.readdirSync(currentPath);

    items.forEach((item) => {
      const itemPath = path.join(currentPath, item);
      const stats = fs.statSync(itemPath);

      // Skip ignored directories
      if (stats.isDirectory() && IGNORE_DIRS.has(item)) {
        return;
      }

      if (stats.isDirectory()) {
        // Recursively scan subdirectories
        scanDirectory(itemPath, exportContent);
      } else {
        // Check if the file matches any of the target extensions
        if ((TARGET_FILE_NAME === "" || item === TARGET_FILE_NAME) && isTargetExtension(item)) {
          console.log(`ðŸ“ Exporting content from: ${itemPath}`);

          // Read the content of the file
          const fileContent = fs.readFileSync(itemPath, 'utf-8');

          // Add a section for this file's code
          exportContent.push(`// File: ${itemPath}\n`);
          exportContent.push(fileContent);
        }

        // Skip ignored files
        if (IGNORE_FILES.has(item)) {
          return;
        }
      }
    });

  } catch (error) {
    console.error(`Error scanning directory ${currentPath}:`, error.message);
  }
}

function isTargetExtension(filename) {
  // Check if the filename ends with any of the target extensions
  return TARGET_EXTENSIONS.some(ext => filename.endsWith(ext));
}

// Run the export generation
generateExport();


// File: E:\Dev\websites\repairradar\scripts\generateModuleImports.js


/* eslint-disable @typescript-eslint/no-require-imports */
// scripts/generateModuleImports.js
const fs = require("fs");
const path = require("path");

// 1. Define paths - use absolute path from project root
const projectRoot = path.resolve(__dirname, "../"); // Go up two levels from scripts/
const modulesDir = path.join(projectRoot, "src/shared/modules");
const outputFile = path.join(modulesDir, "moduleImports.generated.ts");

console.log(`Looking for modules in: ${modulesDir}`); // Debug log

// 2. Get all module folders
let moduleFolders = [];
try {
  moduleFolders = fs.readdirSync(modulesDir).filter((folder) => {
    const folderPath = path.join(modulesDir, folder);
    return fs.statSync(folderPath).isDirectory();
  });
} catch (err) {
  console.error("âŒ Error reading modules directory:", err);
  process.exit(1);
}

console.log("Found modules:", moduleFolders); // Debug log

// 3. Generate import statements
const imports = moduleFolders.map((module) => {
  const componentName = module
    .split("-")
    .map((word) => word[0].toUpperCase() + word.slice(1))
    .join("") + "Page";

  return `  "${module}": () => import("@/shared/modules/${module}/components/${componentName}"),`;
});

const fileContent = `// Auto-generated by scripts/generateModuleImports.js
export const moduleImports: Record<string, () => Promise<{ default: React.ComponentType<{ tenant: string }> }>> = {
${imports.join("\n")}
};
`;

// 4. Write the generated file
try {
  fs.writeFileSync(outputFile, fileContent);
  console.log("âœ… Generated module imports at:", outputFile);
} catch (err) {
  console.error("âŒ Failed to write generated file:", err);
  process.exit(1);
}

// File: E:\Dev\websites\repairradar\scripts\genPrompt.js


/* eslint-disable @typescript-eslint/no-require-imports */
const fs = require('fs');
const path = require('path');
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

// Configure paths
const ROOT_DIR = path.join(__dirname, '..');
const MODULES_DIR = path.join(ROOT_DIR, 'src', 'shared', 'modules');
const EXPORT_DIR = path.join(ROOT_DIR, 'module_exports');

// Enhanced template with AI research instructions
const TEMPLATES = {
  aiPrompt: (ctx) => {
    const needsDBInstruction = ctx.needsDB 
      ? `- Database Model: ${ctx.prismaModel} (Prisma schema required)`
      : `- Database Model: [RESEARCH AND DETERMINE if this module needs database storage]`;
    
    const needsAPIInstruction = ctx.needsAPI
      ? '- API Routes: Required (implement Next.js API routes)'
      : '- API Routes: [RESEARCH AND DETERMINE if this module needs API endpoints]';
    
    const dependenciesInstruction = ctx.dependencies.length
      ? `- Dependencies: ${ctx.dependencies.join(', ')} (already exists in project)`
      : '- Dependencies: [RESEARCH AND DETERMINE if this module depends on other modules]';

    return `# RepairRadar Module Generation Request

## Module Specifications
- Name: ${ctx.moduleName}
- Component: ${ctx.ComponentName}Page
- Description: ${ctx.description}
${needsDBInstruction}
${dependenciesInstruction}

## Technical Requirements
### Architecture Decisions Needed
${needsAPIInstruction}
- State Management: [RESEARCH AND DETERMINE if Zustand or React Context is more appropriate]
- Form Handling: [RESEARCH AND DETERMINE if React Hook Form is needed]

### File Structure Guidance
\`\`\`
${ctx.moduleName}/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ ${ctx.ComponentName}Page.tsx
â”‚   â””â”€â”€ [DETERMINE if additional subcomponents are needed]
â”œâ”€â”€ types.ts
â”œâ”€â”€ [RESEARCH if hooks.ts is needed for custom hooks]
${ctx.needsAPI ? 'â”œâ”€â”€ api/\nâ”‚   â””â”€â”€ route.ts' : '[DETERMINE if API routes folder is needed]'}
â””â”€â”€ README.md
\`\`\`

### Research-Based Implementation
1. Analyze the module description "${ctx.description}" and:
   - Determine optimal data structure
   - Identify required CRUD operations
   - Design appropriate UI components

2. Based on your analysis:
${!ctx.needsDB && !ctx.needsAPI ? `   - [RESEARCH] Does this module need:
   * Database persistence?
   * API endpoints?
   * Both?
   * Neither?` : ''}

3. Create component structure:
\`\`\`tsx
// ${ctx.ComponentName}Page.tsx
"use client";
import { useTenantData } from "@/shared/lib/hooks";
${ctx.dependencies.map(d => `import { use${d}Data } from "@/shared/modules/${d}/hooks";`).join('\n')}
${!ctx.dependencies.length ? '// [RESEARCH if additional imports are needed]' : ''}

export default function ${ctx.ComponentName}Page({ tenant }: { tenant: string }) {
  // [RESEARCH AND IMPLEMENT data fetching logic]
  return (
    <div className="space-y-4">
      {/* [DESIGN appropriate UI based on module purpose] */}
    </div>
  );
}
\`\`\`

## Research Directives
1. If database need is unspecified:
   - Analyze the module's data persistence requirements
   - Recommend appropriate Prisma models if needed
   - Or suggest client-side state if sufficient

2. If API need is unspecified:
   - Determine if server-side processing is required
   - Identify necessary API endpoints
   - Or confirm client-side only implementation

3. For all unspecified aspects:
   - Make reasonable assumptions based on module purpose
   - Document your decisions in code comments
   - Suggest alternatives if appropriate

## Quality Requirements
- Comprehensive JSDoc explaining research decisions
- TypeScript interfaces reflecting data needs
- [RESEARCH appropriate error handling patterns]
- [DETERMINE optimal loading state implementations]
- Mobile-responsive design by default
`;
  },

  moduleGenerator: (ctx) => ({
    name: ctx.moduleName,
    files: [
      {
        path: `components/${ctx.ComponentName}Page.tsx`,
        content: `import { useTenantData } from "@/shared/lib/hooks";
${ctx.dependencies.map(d => `import { use${d}Data } from "@/shared/modules/${d}/hooks";`).join('\n')}

export default function ${ctx.ComponentName}Page({ tenant }: { tenant: string }) {
  return (
    <div className="space-y-4">
      {/* ${ctx.ComponentName} implementation - AI to complete */}
    </div>
  );
}`
      },
      {
        path: 'types.ts',
        content: `export interface ${ctx.ComponentName} {
  id: string;
  tenantId: string;
${ctx.dependencies.map(d => `  ${d}Id?: string;`).join('\n')}
  // AI to add additional fields based on research
}`
      }
    ]
  })
};

// Template rendering function
function renderTemplate(templateFn, context) {
  return templateFn(context);
}

// Project scanning functions
function scanExistingModules() {
  if (!fs.existsSync(MODULES_DIR)) return [];
  return fs.readdirSync(MODULES_DIR).filter(module => {
    const modulePath = path.join(MODULES_DIR, module);
    return fs.statSync(modulePath).isDirectory() && 
           fs.existsSync(path.join(modulePath, 'components'));
  });
}

function scanPrismaModels() {
  const prismaSchemaPath = path.join(ROOT_DIR, 'prisma', 'schema.prisma');
  if (!fs.existsSync(prismaSchemaPath)) return [];
  const schemaContent = fs.readFileSync(prismaSchemaPath, 'utf8');
  const modelMatches = schemaContent.match(/model\s+(\w+)\s*\{/g);
  return modelMatches ? modelMatches.map(m => m.replace('model', '').replace('{', '').trim()) : [];
}

async function collectDependencies(existingModules) {
  const dependencies = [];
  let addMore = true;
  
  while (addMore) {
    console.log('Existing modules:', existingModules.map((m, i) => `[${i}] ${m}`).join(', '));
    const input = await ask('Add dependency (number/name/empty to finish): ');
    
    if (!input) {
      addMore = false;
    } else if (!isNaN(input) && existingModules[input]) {
      dependencies.push(existingModules[input]);
    } else {
      dependencies.push(input);
    }
  }
  return dependencies;
}

function ask(question, validate) {
  return new Promise(resolve => {
    const askFn = () => {
      readline.question(question, answer => {
        if (validate) {
          const error = validate(answer);
          if (error !== true) {
            console.log(`âŒ ${error}`);
            return askFn();
          }
        }
        resolve(answer.trim());
      });
    };
    askFn();
  });
}

function kebabToPascal(str) {
  return str.split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');
}

async function main() {
  console.log('ðŸš€ RepairRadar AI Module Generator\n');

  // Collect module information
  const existingModules = scanExistingModules();
  const prismaModels = scanPrismaModels();

  const context = {
    moduleName: await ask(
      'Module name (kebab-case): ',
      input => /^[a-z]+(-[a-z]+)*$/.test(input) || 'Use kebab-case'
    ),
    description: await ask('Module description: '),
    needsDB: (await ask('Needs DB model? (y/n): ')) === 'y',
    needsAPI: (await ask('Needs API routes? (y/n): ')) === 'y',
    dependencies: await collectDependencies(existingModules),
  };

  // Generate derived values
  context.ComponentName = kebabToPascal(context.moduleName);
  context.prismaModel = context.moduleName.replace(/-/g, '_');

  // Create output directory
  const exportPath = path.join(EXPORT_DIR, `${context.moduleName}_${Date.now()}`);
  fs.mkdirSync(exportPath, { recursive: true });

  // Generate AI prompt
  const promptPath = path.join(exportPath, 'AI_PROMPT.md');
  fs.writeFileSync(promptPath, renderTemplate(TEMPLATES.aiPrompt, context));
  console.log(`ðŸ“ AI Prompt generated at ${promptPath}`);

  // Generate starter files if requested
  if ((await ask('Generate starter files? (y/n): ')) === 'y') {
    const moduleFiles = TEMPLATES.moduleGenerator(context);
    moduleFiles.files.forEach(file => {
      const filePath = path.join(exportPath, file.path);
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      fs.writeFileSync(filePath, file.content);
      console.log(`ðŸ“„ Generated ${file.path}`);
    });
  }

  console.log('\nâœ… Generation complete!');
  console.log('1. Use the AI_PROMPT.md with your AI assistant');
  console.log('2. Implement any suggested starter files');
  console.log(`3. Place module in src/shared/modules/${context.moduleName}`);
  
  readline.close();
}

main().catch(err => {
  console.error('Error:', err);
  readline.close();
  process.exit(1);
});

// File: E:\Dev\websites\repairradar\scripts\genStructureReport.js


// generate-structure-report.js
const fs = require('fs');
const path = require('path');

// Configuration
const REPORT_FILE = 'project_structure_report.txt';
const IGNORE_DIRS = new Set(['node_modules', '.next', '.git', 'dist', 'build']);
const IGNORE_FILES = new Set(['package-lock.json', 'yarn.lock', '.DS_Store']);

function generateReport() {
  try {
    console.log('ðŸ” Analyzing project structure...');
    
    const report = [];
    const rootPath = process.cwd();
    
    // Add metadata
    report.push(`Project Structure Report - ${new Date().toISOString()}`);
    report.push(`Root: ${rootPath}\n`);
    
    // Generate directory tree
    scanDirectory(rootPath, report, 0);
    
    // Write report
    fs.writeFileSync(REPORT_FILE, report.join('\n'));
    
    console.log(`âœ… Report generated: ${REPORT_FILE}`);
    console.log('ðŸ“‹ Please send this file to me so I can create a customized export script for your project.');
    
  } catch (error) {
    console.error('âŒ Failed to generate report:', error);
  }
}

function scanDirectory(currentPath, report, depth) {
  const indent = '  '.repeat(depth);
  const dirName = path.basename(currentPath);
  
  // Skip ignored directories
  if (IGNORE_DIRS.has(dirName)) {
    report.push(`${indent}â””â”€â”€ [${dirName}] (ignored)`);
    return;
  }
  
  report.push(`${indent}â”œâ”€â”€ ${dirName}/`);
  
  try {
    const items = fs.readdirSync(currentPath);
    let fileCount = 0;
    
    items.forEach((item, index) => {
      const itemPath = path.join(currentPath, item);
      const isLast = index === items.length - 1;
      
      try {
        const stats = fs.statSync(itemPath);
        
        if (stats.isDirectory()) {
          scanDirectory(itemPath, report, depth + 1);
        } else {
          // Skip ignored files
          if (IGNORE_FILES.has(item)) {
            report.push(`${indent}${isLast ? 'â””' : 'â”œ'}â”€â”€ ${item} (ignored)`);
            return;
          }
          
          fileCount++;
          const prefix = depth === 0 ? 'â”‚   ' : '    ';
          const fileInfo = `${indent}${isLast ? 'â””' : 'â”œ'}â”€â”€ ${item} (${formatFileSize(stats.size)})`;
          report.push(fileInfo);
        }
      } catch (err) {
        report.push(`${indent}${isLast ? 'â””' : 'â”œ'}â”€â”€ ${item} (error: ${err.message})`);
      }
    });
    
    if (fileCount === 0 && items.length > 0) {
      report[report.length - 1] = report[report.length - 1].replace('â”œâ”€â”€', 'â””â”€â”€');
    }
    
  } catch (error) {
    report.push(`${indent}â””â”€â”€ (error reading directory: ${error.message})`);
  }
}

function formatFileSize(bytes) {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1048576) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / 1048576).toFixed(1)} MB`;
}

// Run the report generation
generateReport();

// File: E:\Dev\websites\repairradar\src\app\admin\page.tsx


"use client";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect, useState, useCallback, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { toast } from "sonner"; // Import toast directly from sonner
import ClientToaster from "@/components/ClientToaster"; // Only import the component
import { Loader2 } from "lucide-react";
import { ModuleManager } from "@/shared/modules/moduleManager";

const ALL_MODULES = ModuleManager.getAllModules();

type Tenant = { id: string; name: string; subdomain: string; config?: { modules: Record<string, boolean> } | null; deletedAt: string | null };
type ModuleConfig = Record<string, boolean>;

export default function AdminPanel() {
  const { data: session, status } = useSession();
  const router = useRouter();
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [newTenant, setNewTenant] = useState<{
    name: string;
    subdomain: string;
    modules: ModuleConfig;
  }>({
    name: "",
    subdomain: "",
    modules: ALL_MODULES.reduce((acc, m) => ({ ...acc, [m]: false }), {} as ModuleConfig),
  });
  const [initialLoading, setInitialLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState(false);
  const [actionType, setActionType] = useState<string | null>(null);
  const [targetId, setTargetId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const isMounted = useRef(false);

  const fetchTenants = useCallback(async (isInitialFetch = false) => {
    try {
      if (isInitialFetch) setInitialLoading(true);
      const res = await fetch("/api/tenants");
      if (!res.ok) throw new Error(`Failed to fetch tenants: ${res.statusText}`);
      setTenants(await res.json());
    } catch (err) {
      setError(err instanceof Error ? err.message : "An unexpected error occurred");
      toast.error("Could not load tenants");
    } finally {
      if (isInitialFetch) setInitialLoading(false);
    }
  }, []); // No dependencies, stable function

  useEffect(() => {
    if (!isMounted.current && status === "authenticated" && session?.user?.role === "SUPER_ADMIN") {
      fetchTenants(true); // Initial fetch
      isMounted.current = true;
    }
  }, [session, status, fetchTenants]);

  const handleCreateTenant = useCallback(
    async (e: React.FormEvent) => {
      e.preventDefault();
      if (actionLoading) return;
      setActionLoading(true);
      setActionType("create");
      try {
        const res = await fetch("/api/tenants", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(newTenant),
        });
        if (!res.ok) throw new Error(`Failed to create tenant: ${await res.text()}`);
        setNewTenant({ name: "", subdomain: "", modules: ALL_MODULES.reduce((acc, m) => ({ ...acc, [m]: false }), {} as ModuleConfig) });
        await fetchTenants();
        toast.success("Tenant created successfully");
      } catch (err) {
        toast.error(err instanceof Error ? err.message : "Could not create tenant");
      } finally {
        setActionLoading(false);
        setActionType(null);
      }
    },
    [newTenant, fetchTenants, actionLoading]
  );

  const handleSoftDeleteTenant = useCallback(
    async (id: string) => {
      if (actionLoading) return;
      setActionLoading(true);
      setActionType("softDelete");
      setTargetId(id);
      try {
        const res = await fetch(`/api/tenants/${id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "X-Action": "softDeleteTenant",
          },
          body: JSON.stringify({}),
        });
        if (!res.ok) throw new Error(`Failed to soft delete tenant: ${await res.text()}`);
        await fetchTenants();
        toast.success(`Tenant ${id} soft deleted successfully`);
      } catch (err) {
        toast.error(err instanceof Error ? err.message : "Could not soft delete tenant");
      } finally {
        setActionLoading(false);
        setActionType(null);
        setTargetId(null);
      }
    },
    [fetchTenants, actionLoading]
  );

  const handleRestoreTenant = useCallback(
    async (id: string) => {
      if (actionLoading) return;
      setActionLoading(true);
      setActionType("restore");
      setTargetId(id);
      try {
        const res = await fetch(`/api/tenants/${id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "X-Action": "restoreTenant",
          },
          body: JSON.stringify({}),
        });
        if (!res.ok) {
          const errorText = await res.text();
          console.error("Restore failed:", errorText);
          throw new Error(`Failed to restore tenant: ${errorText}`);
        }
        await fetchTenants();
        toast.success("Tenant restored");
      } catch (err) {
        toast.error(err instanceof Error ? err.message : "Could not restore tenant");
      } finally {
        setActionLoading(false);
        setActionType(null);
        setTargetId(null);
      }
    },
    [fetchTenants, actionLoading]
  );

  const handleUpdateModules = useCallback(
    async (tenant: Tenant, module: string, enabled: boolean) => {
      if (actionLoading) return;
      setActionLoading(true);
      setActionType(`updateModule-${module}`);
      setTargetId(tenant.id);
      try {
        const updatedModules = { ...tenant.config?.modules, [module]: enabled };
        const res = await fetch(`/api/tenants/${tenant.id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "X-Action": "updateTenant",
          },
          body: JSON.stringify({ modules: updatedModules }),
        });
        if (!res.ok) throw new Error(`Failed to update tenant modules: ${await res.text()}`);
        await fetchTenants();
        toast.success("Tenant modules updated");
      } catch (err) {
        toast.error(err instanceof Error ? err.message : "Could not update tenant modules");
      } finally {
        setActionLoading(false);
        setActionType(null);
        setTargetId(null);
      }
    },
    [fetchTenants, actionLoading]
  );

  const handleHardDeleteTenant = useCallback(
    async (id: string) => {
      if (actionLoading || !confirm("Are you sure you want to permanently delete this tenant? This action cannot be undone.")) return;
      setActionLoading(true);
      setActionType("hardDelete");
      setTargetId(id);
      try {
        const res = await fetch(`/api/tenants/${id}`, {
          method: "DELETE",
        });
        if (!res.ok) throw new Error(`Failed to permanently delete tenant: ${await res.text()}`);
        await fetchTenants();
        toast.success("Tenant permanently deleted");
      } catch (err) {
        toast.error(err instanceof Error ? err.message : "Could not permanently delete tenant");
      } finally {
        setActionLoading(false);
        setActionType(null);
        setTargetId(null);
      }
    },
    [fetchTenants, actionLoading]
  );

  const handleViewDashboard = useCallback((subdomain: string) => {
    window.open("/" + subdomain, "_blank"); // Open in new tab to avoid leaving /admin
  }, []);

  const formatDeletedAt = (deletedAt: string | null) => {
    if (!deletedAt) return "";
    return new Date(deletedAt).toISOString().split("T")[0] + " " + new Date(deletedAt).toISOString().split("T")[1].split(".")[0];
  };

  if (status === "loading" || initialLoading) {
    return <div className="p-6">Loading...</div>;
  }

  if (status === "unauthenticated" || session?.user?.role !== "SUPER_ADMIN") {
    router.push("/auth/signin");
    return null;
  }

  if (error) return <div className="p-6 text-red-500">{error}</div>;

  return (
    <div className="p-6 max-w-7xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Admin Panel</h1>
      <Card className="mb-8">
        <CardHeader>
          <CardTitle>Create Tenant</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleCreateTenant} className="space-y-4">
            <Input
              value={newTenant.name}
              onChange={(e) => setNewTenant({ ...newTenant, name: e.target.value })}
              placeholder="Tenant Name"
              required
              disabled={actionLoading}
            />
            <Input
              value={newTenant.subdomain}
              onChange={(e) => setNewTenant({ ...newTenant, subdomain: e.target.value.toLowerCase() })}
              placeholder="Subdomain"
              required
              disabled={actionLoading}
            />
            <div className="space-y-2">
              <h3 className="text-lg font-semibold">Modules:</h3>
              {ALL_MODULES.map((mod) => (
                <div key={mod} className="flex items-center space-x-2">
                  <Checkbox
                    id={mod}
                    checked={newTenant.modules?.[mod] || false}
                    onCheckedChange={(checked) =>
                      setNewTenant({ ...newTenant, modules: { ...newTenant.modules, [mod]: checked as boolean } })
                    }
                    disabled={actionLoading}
                  />
                  <label htmlFor={mod} className="text-sm">{mod}</label>
                </div>
              ))}
            </div>
            <Button type="submit" disabled={actionLoading}>
              {actionLoading && actionType === "create" ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Creating...
                </>
              ) : (
                "Create Tenant"
              )}
            </Button>
          </form>
        </CardContent>
      </Card>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {tenants.map((t) => (
          <Card key={t.id} className={t.deletedAt ? "opacity-50" : ""}>
            <CardHeader>
              {t.deletedAt ? (
                <CardTitle>
                  {t.name} ({t.subdomain}) - Deleted at {formatDeletedAt(t.deletedAt)}
                </CardTitle>
              ) : (
                <CardTitle>
                  {t.name} ({t.subdomain})
                </CardTitle>
              )}
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <h4 className="font-semibold">Modules:</h4>
                {ALL_MODULES.map((mod) => (
                  <div key={mod} className="flex items-center space-x-2">
                    <Checkbox
                      id={`${t.id}-${mod}`}
                      checked={t.config?.modules?.[mod] || false}
                      onCheckedChange={(checked) => handleUpdateModules(t, mod, checked as boolean)}
                      disabled={Boolean(t.deletedAt) || (actionLoading && actionType?.startsWith("updateModule") && targetId === t.id)}
                    />
                    <label htmlFor={`${t.id}-${mod}`} className="text-sm">
                      {mod}
                      {actionLoading && actionType === `updateModule-${mod}` && targetId === t.id && (
                        <Loader2 className="ml-2 inline h-3 w-3 animate-spin" />
                      )}
                    </label>
                  </div>
                ))}
              </div>
              <Button
                variant="default"
                className="mt-4"
                onClick={() => handleViewDashboard(t.subdomain)}
                disabled={Boolean(t.deletedAt)}
                type="button"
              >
                View Dashboard
              </Button>
              {t.deletedAt ? (
                <>
                  <Button
                    variant="default"
                    className="mt-4 ml-2"
                    onClick={() => handleRestoreTenant(t.id)}
                    disabled={actionLoading && actionType === "restore" && targetId === t.id}
                    type="button"
                  >
                    {actionLoading && actionType === "restore" && targetId === t.id ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Restoring...
                      </>
                    ) : (
                      "Restore"
                    )}
                  </Button>
                  <Button
                    variant="destructive"
                    className="mt-4 ml-2"
                    onClick={() => handleHardDeleteTenant(t.id)}
                    disabled={actionLoading && actionType === "hardDelete" && targetId === t.id}
                    type="button"
                  >
                    {actionLoading && actionType === "hardDelete" && targetId === t.id ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Deleting...
                      </>
                    ) : (
                      "Permanently Delete"
                    )}
                  </Button>
                </>
              ) : (
                <Button
                  variant="destructive"
                  className="mt-4 ml-2"
                  onClick={() => handleSoftDeleteTenant(t.id)}
                  disabled={actionLoading && actionType === "softDelete" && targetId === t.id}
                  type="button"
                >
                  {actionLoading && actionType === "softDelete" && targetId === t.id ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Soft Deleting...
                    </>
                  ) : (
                    "Soft Delete"
                  )}
                </Button>
              )}
            </CardContent>
          </Card>
        ))}
      </div>
      <ClientToaster />
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\app\api\auth\api\route.ts


import { NextResponse } from "next/server";
import { prisma } from "@/shared/lib/db";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";

export async function GET(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const url = new URL(req.url);
  const subdomain = url.searchParams.get("subdomain");

  if (subdomain) {
    const tenant = await prisma.tenants.findUnique({
      where: { subdomain, deletedAt: null },
      include: { config: true },
    });
    if (!tenant) return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
    return NextResponse.json(tenant);
  }

  const tenants = await prisma.tenants.findMany({ include: { config: true } });
  return NextResponse.json(tenants);
}

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { name, subdomain, modules } = await req.json();
  const tenant = await prisma.tenants.create({
    data: { name, subdomain, config: { create: { modules } } },
  });
  return NextResponse.json(tenant, { status: 201 });
}

export async function PUT(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const action = req.headers.get("X-Action");
  if (action === "updateTenant") return await handleUpdateModules(req);
  if (action === "deleteTenant") return await handleDeleteTenant(req);
  if (action === "restoreTenant") return await handleRestoreTenant(req);
  return NextResponse.json({ error: "Invalid action" }, { status: 400 });
}

async function handleUpdateModules(req: Request) {
  const url = new URL(req.url);
  const id = url.searchParams.get("id");
  const { modules } = await req.json();
  if (!id) return NextResponse.json({ error: "Missing tenant ID" }, { status: 400 });

  try {
    const tenant = await prisma.tenants.update({
      where: { id, deletedAt: null }, // Only update active tenants
      data: { config: { update: { modules } } },
    });
    return NextResponse.json(tenant);
  } catch (error) {
    console.error("Update modules failed:", error);
    return NextResponse.json({ error: "Failed to update modules" }, { status: 500 });
  }
}

async function handleDeleteTenant(req: Request) {
  const url = new URL(req.url);
  const id = url.searchParams.get("id");
  if (!id) return NextResponse.json({ error: "Missing tenant ID" }, { status: 400 });

  try {
    const tenant = await prisma.tenants.update({
      where: { id, deletedAt: null }, // Only delete active tenants
      data: { deletedAt: new Date() },
    });
    return NextResponse.json(tenant);
  } catch (error) {
    console.error("Soft delete failed:", error);
    return NextResponse.json({ error: "Failed to soft delete tenant" }, { status: 500 });
  }
}

async function handleRestoreTenant(req: Request) {
  const url = new URL(req.url);
  const id = url.searchParams.get("id");
  if (!id) return NextResponse.json({ error: "Missing tenant ID" }, { status: 400 });

  try {
    const tenant = await prisma.tenants.findUnique({ where: { id } });
    if (!tenant) return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
    if (!tenant.deletedAt) return NextResponse.json({ error: "Tenant is already active" }, { status: 400 });

    const updatedTenant = await prisma.tenants.update({
      where: { id },
      data: { deletedAt: null },
    });
    return NextResponse.json(updatedTenant);
  } catch (error) {
    console.error("Restore tenant failed:", error);
    return NextResponse.json({ error: "Failed to restore tenant" }, { status: 500 });
  }
}

export async function DELETE(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const url = new URL(req.url);
  const id = url.searchParams.get("id");
  if (!id) return NextResponse.json({ error: "Missing tenant ID" }, { status: 400 });

  const tenant = await prisma.tenants.delete({ where: { id } });
  return NextResponse.json(tenant);
}

// File: E:\Dev\websites\repairradar\src\app\api\auth\[...nextauth]\route.ts


import NextAuth, { NextAuthOptions, Session, User } from "next-auth";
import { JWT } from "next-auth/jwt";
import CredentialsProvider from "next-auth/providers/credentials";
import { prisma } from "@/shared/lib/db";

export const authOptions: NextAuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) return null;
        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });
        if (user && user.password === credentials.password) {
          return { id: user.id, email: user.email, tenantId: user.tenantId, role: user.role };
        }
        return null;
      },
    }),
  ],
  session: { strategy: "jwt" as const }, // Explicitly type as SessionStrategy
  pages: { signIn: "/auth/signin" },
  callbacks: {
    async jwt({ token, user }: { token: JWT; user?: User }) {
      if (user) {
        token.id = user.id;
        token.tenantId = user.tenantId;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }: { session: Session; token: JWT }) {
      session.user.id = token.id as string;
      session.user.tenantId = token.tenantId as string | null;
      session.user.role = token.role as string | null;
      return session;
    },  },
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// File: E:\Dev\websites\repairradar\src\app\api\tenants\route.ts


// src/app/api/tenants/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/shared/lib/db";
import { getServerSession } from "next-auth/next";
import { authOptions } from "../auth/[...nextauth]/route";

export async function GET(req: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const { searchParams } = new URL(req.url);
  const subdomain = searchParams.get("subdomain");

  if (subdomain) {
    const tenant = await prisma.tenants.findUnique({
      where: { subdomain, deletedAt: null },
      include: { config: true },
    });
    if (!tenant) return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
    return NextResponse.json(tenant);
  }

  // Fetch all tenants for SUPER_ADMIN only
  if (session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }
  const tenants = await prisma.tenants.findMany({
    where: { deletedAt: null },
    include: { config: true },
  });
  return NextResponse.json(tenants);
}

export async function POST(req: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { name, subdomain, modules } = await req.json();
  const tenant = await prisma.tenants.create({
    data: {
      name,
      subdomain,
      config: { create: { modules } },
    },
    include: { config: true },
  });
  return NextResponse.json(tenant, { status: 201 });
}

// File: E:\Dev\websites\repairradar\src\app\api\tenants\[tenantId]\route.ts


// src/app/api/tenants/[tenantId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/shared/lib/db";
import { getServerSession } from "next-auth/next";
import { authOptions } from "../../auth/[...nextauth]/route";

// Await params explicitly
export async function GET(req: NextRequest, context: { params: Promise<{ tenantId: string }> }) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const { tenantId } = await context.params; // Await params
  const { searchParams } = new URL(req.url);
  const subdomain = searchParams.get("subdomain");

  const tenant = await prisma.tenants.findUnique({
    where: subdomain ? { subdomain } : { id: tenantId, deletedAt: null },
    include: { config: true },
  });

  if (!tenant) return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
  return NextResponse.json(tenant);
}

export async function PUT(req: NextRequest, context: { params: Promise<{ tenantId: string }> }) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const action = req.headers.get("X-Action");
  const body = await req.json();
  const { tenantId } = await context.params; // Await params

  if (action === "updateTenant") {
    const { modules } = body;
    const tenant = await prisma.tenants.update({
      where: { id: tenantId },
      data: {
        config: {
          upsert: {
            create: { modules },
            update: { modules },
          },
        },
      },
      include: { config: true },
    });
    return NextResponse.json(tenant);
  }else if (action === "softDeleteTenant") {
    const tenant = await prisma.tenants.update({
      where: { id: tenantId },
      data: { deletedAt: new Date() },
    });
    return NextResponse.json({ message: "Tenant soft deleted" + tenant.id });
  }
  return NextResponse.json({ error: "Invalid action " + action }, { status: 400 });
}

export async function DELETE(req: NextRequest, context: { params: Promise<{ tenantId: string }> }) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "SUPER_ADMIN") {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { tenantId } = await context.params; // Await params
  await prisma.tenants.delete({ where: { id: tenantId } });
  return NextResponse.json({ message: "Tenant deleted" });
}

// File: E:\Dev\websites\repairradar\src\app\api\[module]\route.ts


import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/shared/lib/db";
import { getServerSession } from "next-auth/next";
import { authOptions } from "../auth/[...nextauth]/route";
import { ModuleManager } from "@/shared/modules/moduleManager";

// Map module names to Prisma models and optional custom configs
const moduleConfig: Record<
  string,
  {
    model: any;
    metrics?: (items: any[]) => Record<string, number>; // Optional metrics function
    include?: any; // For relations like asset, reportedBy
  }
> = {
  assets: {
    model: prisma.asset,
    metrics: (items) => ({
      total: items.length,
      operational: items.filter((item) => item.status === "OPERATIONAL").length,
    }),
  },
  calls: {
    model: prisma.call,
    metrics: (items) => ({
      total: items.length,
      open: items.filter((item) => item.status === "OPEN").length,
    }),
    include: { asset: true, reportedBy: { select: { id: true, email: true } } },
  },
  "work-orders": {
    model: prisma.workOrder,
    metrics: (items) => ({
      total: items.length,
      active: items.filter((item) => item.status === "ACTIVE").length,
    }),
    include: { assets: { include: { asset: true } }, notes: true, assignedTo: true },
  },
  "preventative-maintenance": {
    model: prisma.maintenanceSchedule,
    metrics: (items) => ({
      total: items.length,
      scheduled: items.filter((item) => item.status === "SCHEDULED").length,
    }),
    include: {
      assets: { include: { asset: { select: { id: true, name: true } } } },
      assignedTo: { select: { id: true, email: true } },
    },
  },
  dashboard: { model: null }, // Special case, handled separately
};

async function handleRequest(req: NextRequest, method: string, module: string) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const url = new URL(req.url);
  const tenantSubdomain = url.searchParams.get("tenant");
  const id = url.searchParams.get("id");
  const config = moduleConfig[module];

  // Validate module
  if (!config) {
    return NextResponse.json({ error: `Invalid module: ${module}` }, { status: 400 });
  }

  // Special handling for dashboard
  if (module === "dashboard") {
    if (method !== "GET") {
      return NextResponse.json({ error: "Method not allowed for dashboard" }, { status: 405 });
    }
    return handleDashboardRequest(tenantSubdomain);
  }

  // Validate tenant
  if (!tenantSubdomain) {
    return NextResponse.json({ error: "Tenant subdomain required" }, { status: 400 });
  }
  const tenant = await prisma.tenants.findUnique({
    where: { subdomain: tenantSubdomain, deletedAt: null },
    include: { config: true },
  });
  if (!tenant) {
    return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
  }

  const model = config.model;
  const include = config.include || {};

  try {
    switch (method) {
      case "GET":
        const items = await model.findMany({
          where: { tenantId: tenant.id, deletedAt: null },
          include,
          orderBy: { createdAt: "desc" }, // Default ordering
        });
        // Return metrics for dashboard compatibility
        if (config.metrics) {
          return NextResponse.json(config.metrics(items));
        }
        return NextResponse.json(items);

      case "POST":
        if (session.user.role !== "ADMIN" && session.user.role !== "SUPER_ADMIN") {
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }
        const createData = await req.json();
        const newItem = await model.create({
          data: { ...createData, tenantId: tenant.id },
          include,
        });
        return NextResponse.json(newItem, { status: 201 });

      case "PUT":
        if (session.user.role !== "ADMIN" && session.user.role !== "SUPER_ADMIN") {
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }
        if (!id) return NextResponse.json({ error: "Missing ID" }, { status: 400 });
        const action = req.headers.get("X-Action");
        const updateData = await req.json();

        if (action === "delete") {
          const deletedItem = await model.update({
            where: { id, tenantId: tenant.id },
            data: { deletedAt: new Date() },
            include,
          });
          return NextResponse.json(deletedItem);
        } else if (action === "restore") {
          const restoredItem = await model.update({
            where: { id, tenantId: tenant.id },
            data: { deletedAt: null },
            include,
          });
          return NextResponse.json(restoredItem);
        } else {
          const updatedItem = await model.update({
            where: { id, tenantId: tenant.id },
            data: updateData,
            include,
          });
          return NextResponse.json(updatedItem);
        }

      case "DELETE":
        if (session.user.role !== "ADMIN" && session.user.role !== "SUPER_ADMIN") {
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }
        if (!id) return NextResponse.json({ error: "Missing ID" }, { status: 400 });
        await model.delete({ where: { id, tenantId: tenant.id } });
        return NextResponse.json({ message: `${module} permanently deleted` });

      default:
        return NextResponse.json({ error: "Method not allowed" }, { status: 405 });
    }
  } catch (error) {
    console.error(`Error for ${module} ${method}:`, error);
    return NextResponse.json({ error: "Internal server error" }, { status: 500 });
  }
}

// Dashboard-specific logic
async function handleDashboardRequest(tenantSubdomain: string | null) {
  if (!tenantSubdomain) {
    return NextResponse.json({ error: "Tenant required" }, { status: 400 });
  }

  const res = await fetch(`http://localhost:3000/api/tenants?subdomain=${tenantSubdomain}`);
  if (!res.ok) return NextResponse.json({ error: "Config fetch failed" }, { status: 500 });
  const { config } = await res.json();

  const modules = ModuleManager.getActiveModules(config).filter((mod) => mod.name !== "dashboard");

  const metrics = await Promise.all(
    modules.map(async (mod) => {
      const modRes = await fetch(`http://localhost:3000/api/${mod.name}?tenant=${tenantSubdomain}`);
      return { [mod.name]: modRes.ok ? await modRes.json() : null };
    })
  );

  return NextResponse.json({
    tenant: tenantSubdomain,
    metrics: Object.assign({}, ...metrics),
  });
}

export async function GET(req: NextRequest, { params }: { params: { module: string } }) {
  return handleRequest(req, "GET", params.module);
}

export async function POST(req: NextRequest, { params }: { params: { module: string } }) {
  return handleRequest(req, "POST", params.module);
}

export async function PUT(req: NextRequest, { params }: { params: { module: string } }) {
  return handleRequest(req, "PUT", params.module);
}

export async function DELETE(req: NextRequest, { params }: { params: { module: string } }) {
  return handleRequest(req, "DELETE", params.module);
}

export const dynamic = "force-dynamic";

// File: E:\Dev\websites\repairradar\src\app\auth\signin\page.tsx


"use client";
import { signIn } from "next-auth/react";
import { useState } from "react";
import { useRouter } from "next/navigation";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

export default function SignIn() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    console.log("[SignIn] Attempting sign-in with:", { email, password });
    const result = await signIn("credentials", {
      redirect: false,
      email,
      password,
    });
    console.log("[SignIn] Result:", result);
    if (result?.error) {
      setError("Invalid credentials");
    } else {
      router.push("/admin");
    }
  };

  return (
    <div className="p-6 max-w-md mx-auto">
      <h1 className="text-2xl mb-4">Sign In</h1>
      <form onSubmit={handleSubmit} className="space-y-4">
        <Input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          placeholder="Email"
          required
        />
        <Input
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          placeholder="Password"
          required
        />
        {error && <p className="text-red-500">{error}</p>}
        <Button type="submit">Sign In</Button>
      </form>
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\app\debug-session\page.tsx


"use client";
import { useSession } from "next-auth/react";

export default function DebugSession() {
  const { data: session, status } = useSession();
  console.log("Client Status:", status, "Session:", session);

  return (
    <div className="p-6">
      <h1>Session Debug</h1>
      <p>Status: {status}</p>
      <pre>{JSON.stringify(session, null, 2)}</pre>
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\app\layout.tsx


import { getServerSession } from "next-auth/next";
import SessionWrapper from "@/components/SessionWrapper";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import ThemeWrapper from "@/components/ThemeWrapper"; // Import from sonner
import "./globals.css";

export const metadata = {
  title: "RepairRadar",
  description: "A multi-tenant CMMS platform",
};

export default async function RootLayout({ children }: { children: React.ReactNode }) {
  const session = await getServerSession(authOptions);
  console.log("[RootLayout] Session:", session);
  return (
    <html lang="en">
      <body>
          <SessionWrapper session={session}>
            <ThemeWrapper>
              <main>{children}</main>
            </ThemeWrapper>
          </SessionWrapper>
      </body>
    </html>
  );
}


// File: E:\Dev\websites\repairradar\src\app\page.tsx


import Link from "next/link";

export default function Home() {
  return (
    <div className="p-6">
      <h1 className="text-2xl">Welcome to RepairRadar</h1>
      <p>Please <Link  href="/auth/signin" className="text-blue-500">sign in</Link> to continue.</p>
    </div>
  );
}


// File: E:\Dev\websites\repairradar\src\app\[tenant]\page.tsx


"use client";
import { useSession } from "next-auth/react";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState, useCallback, useRef } from "react";
import dynamic from "next/dynamic";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { toast } from "sonner";
import ClientToaster from "@/components/ClientToaster";
import { ModuleManager } from "@/shared/modules/moduleManager";
import { Tenants } from "@prisma/client";
import { Module, TenantConfig } from "@/shared/modules/types";
import { Loader2 } from "lucide-react";
import Navbar from "@/components/Navbar";

export default function TenantPage() {
  const { status } = useSession();
  const router = useRouter();
  const { tenant } = useParams();
  const [tenantConfig, setTenantConfig] = useState<TenantConfig | null>(null);
  const [activeModules, setActiveModules] = useState<Module[]>([]);
  const [selectedModule, setSelectedModule] = useState<Module | null>(null);
  const [initialLoading, setInitialLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const isMounted = useRef(false);

  const fetchTenantConfig = useCallback(async (isInitialFetch = false) => {
    try {
      if (isInitialFetch) setInitialLoading(true);
      setActionLoading(true);
      const res = await fetch(`/api/tenants?subdomain=${tenant}`);
      if (res.status === 401) {
        router.push("/auth/signin");
        return;
      }
      if (!res.ok) throw new Error(`Failed to fetch tenant config: ${res.statusText}`);
      const data: Tenants & { config?: TenantConfig } = await res.json();
      if (!data.config) throw new Error("Tenant config not found");

      setTenantConfig(data.config);
      const rawModules: Module[] = ModuleManager.getActiveModules(data.config).map((mod) => ({
        ...mod,
        component: dynamic(mod.component, { ssr: false }),
      }));
      toast.success(rawModules.length + " module(s) loaded successfully");
      setActiveModules(rawModules);
      if (!selectedModule || !rawModules.some((m) => m.name === selectedModule.name)) {
        setSelectedModule(rawModules[0] || null);
      }
    } catch (err) {
      const errorMsg = err instanceof Error ? err.message : "An unexpected error occurred";
      setError(errorMsg);
      toast.error(errorMsg);
    } finally {
      setActionLoading(false);
      if (isInitialFetch) setInitialLoading(false);
    }
  }, [tenant, router, selectedModule]);

  useEffect(() => {
    if (!isMounted.current && status === "authenticated") {
      fetchTenantConfig(true);
      isMounted.current = true;
    }
    if (status === "unauthenticated") router.push("/auth/signin");
  }, [status, fetchTenantConfig, router]);

  const handleSelectModule = useCallback((module: Module) => {
    setSelectedModule(module);
    toast.success(`Switched to ${module.name.replace("-", " ")} module`);
  }, []);

  if (status === "loading" || initialLoading) {
    return (
      <div className="p-6 flex items-center justify-center">
        <Loader2 className="h-6 w-6 animate-spin" /> <span className="ml-2">Loading...</span>
      </div>
    );
  }
  if (status === "unauthenticated") return null;
  if (error) return <div className="p-4 text-red-500">{error}</div>;
  if (!tenantConfig) return <div className="p-4">No tenant configuration found.</div>;

  return (
    <div className="flex flex-col min-h-screen">
      <Navbar
        tenant={tenant as string}
        activeModules={activeModules}
        selectedModule={selectedModule}
        onSelectModule={handleSelectModule}
        actionLoading={actionLoading}
      />
      <main className="flex-1 p-6 max-w-7xl mx-auto w-full">
        {activeModules.length === 0 ? (
          <Card>
            <CardContent className="pt-6">
              <p>No modules enabled for this tenant.</p>
            </CardContent>
          </Card>
        ) : (
          <Card>
            <CardHeader>
              <CardTitle>
                {selectedModule
                  ? `${selectedModule.name.charAt(0).toUpperCase() + selectedModule.name.slice(1).replace("-", " ")}`
                  : "No Module Selected"}
              </CardTitle>
            </CardHeader>
            <CardContent>
              {selectedModule ? (
                actionLoading ? (
                  <div className="flex items-center justify-center">
                    <Loader2 className="h-6 w-6 animate-spin" /> <span className="ml-2">Loading module...</span>
                  </div>
                ) : typeof selectedModule.component === "function" ? (
                  <selectedModule.component tenant={tenant as string} />
                ) : (
                  <p className="text-red-500">
                    Error: {selectedModule.name} module failed to load correctly.
                  </p>
                )
              ) : (
                <p className="text-gray-500">Select a module to view its content.</p>
              )}
            </CardContent>
          </Card>
        )}
        <ClientToaster />
      </main>
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\components\ClientToaster.tsx


"use client";
import { Toaster, toast } from "sonner";

export default function ClientToaster() {
  return <Toaster richColors theme="system" />;
}

export { toast };

// File: E:\Dev\websites\repairradar\src\components\EditDialog.tsx


// src/components/common/EditDialog.tsx
'use client';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Loader2, CalendarIcon, Clock } from 'lucide-react';
import { useState } from 'react';
import { format } from 'date-fns';

type StatusOption = {
  value: string;
  label: string;
};

type FieldType = 'text' | 'number' | 'select' | 'date' | 'time' | 'datetime';

type EditDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description?: string;
  initialData: Record<string, any>;
  fields: {
    name: string;
    label: string;
    type: FieldType;
    required?: boolean;
    options?: StatusOption[];
  }[];
  onSubmit: (data: Record<string, any>) => Promise<void>;
};

export function EditDialog({
  open,
  onOpenChange,
  title,
  description,
  initialData,
  fields,
  onSubmit,
}: EditDialogProps) {
  const [formData, setFormData] = useState(initialData);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      await onSubmit(formData);
      onOpenChange(false);
    } catch (error) {
      console.error('Error submitting form:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleChange = (name: string, value: string | Date) => {
    // Convert Date objects to ISO strings for consistent storage
    const formattedValue = value instanceof Date ? value.toISOString() : value;
    setFormData(prev => ({ ...prev, [name]: formattedValue }));
  };

  const renderField = (field: {
    name: string;
    label: string;
    type: FieldType;
    required?: boolean;
    options?: StatusOption[];
  }) => {
    switch (field.type) {
      case 'select':
        return (
          <Select
            value={formData[field.name] || ''}
            onValueChange={(value) => handleChange(field.name, value)}
          >
            <SelectTrigger>
              <SelectValue placeholder={`Select ${field.label.toLowerCase()}`} />
            </SelectTrigger>
            <SelectContent>
              {field.options?.map(option => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case 'date':
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button
                variant="outline"
                className="w-full justify-start text-left font-normal"
              >
                <CalendarIcon className="mr-2 h-4 w-4" />
                {formData[field.name] ? (
                  format(new Date(formData[field.name]), 'PPP')
                ) : (
                  <span>Pick a date</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={formData[field.name] ? new Date(formData[field.name]) : undefined}
                onSelect={(date) => date && handleChange(field.name, date)}
                initialFocus
              />
            </PopoverContent>
          </Popover>
        );

      case 'time':
        return (
          <div className="relative">
            <Clock className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
            <Input
              type="time"
              className="pl-9"
              value={formData[field.name] || ''}
              onChange={(e) => handleChange(field.name, e.target.value)}
              required={field.required}
            />
          </div>
        );

      case 'datetime':
        return (
          <div className="flex gap-2">
            <Popover>
              <PopoverTrigger asChild>
                <Button
                  variant="outline"
                  className="w-full justify-start text-left font-normal"
                >
                  <CalendarIcon className="mr-2 h-4 w-4" />
                  {formData[field.name] ? (
                    format(new Date(formData[field.name]), 'PPP')
                  ) : (
                    <span>Pick a date</span>
                  )}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0">
                <Calendar
                  mode="single"
                  selected={formData[field.name] ? new Date(formData[field.name]) : undefined}
                  onSelect={(date) => {
                    if (date) {
                      const current = formData[field.name] ? new Date(formData[field.name]) : new Date();
                      date.setHours(current.getHours());
                      date.setMinutes(current.getMinutes());
                      handleChange(field.name, date);
                    }
                  }}
                  initialFocus
                />
              </PopoverContent>
            </Popover>
            <div className="relative">
              <Clock className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
              <Input
                type="time"
                className="pl-9"
                value={formData[field.name] ? format(new Date(formData[field.name]), 'HH:mm') : ''}
                onChange={(e) => {
                  const time = e.target.value;
                  if (time) {
                    const [hours, minutes] = time.split(':');
                    const date = formData[field.name] ? new Date(formData[field.name]) : new Date();
                    date.setHours(parseInt(hours, 10));
                    date.setMinutes(parseInt(minutes, 10));
                    handleChange(field.name, date);
                  }
                }}
                required={field.required}
              />
            </div>
          </div>
        );

      default:
        return (
          <Input
            id={field.name}
            type={field.type}
            value={formData[field.name] || ''}
            onChange={(e) => handleChange(field.name, e.target.value)}
            required={field.required}
          />
        );
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          {description && <DialogDescription>{description}</DialogDescription>}
        </DialogHeader>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          {fields.map(field => (
            <div key={field.name} className="space-y-2">
              <Label htmlFor={field.name}>
                {field.label}
                {field.required && <span className="text-red-500 ml-1">*</span>}
              </Label>
              {renderField(field)}
            </div>
          ))}
          
          <div className="flex justify-end gap-2 pt-4">
            <Button
              variant="outline"
              type="button"
              onClick={() => onOpenChange(false)}
              disabled={isLoading}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={isLoading}>
              {isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Save Changes
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}

// File: E:\Dev\websites\repairradar\src\components\Navbar.tsx


"use client";
import { useSession, signOut } from "next-auth/react";
import { useRouter, usePathname } from "next/navigation";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Module } from "@/shared/modules/types";

interface NavbarProps {
  tenant?: string;
  activeModules?: Module[];
  selectedModule?: Module | null;
  onSelectModule?: (module: Module) => void;
  actionLoading?: boolean;
}

export default function Navbar({
  tenant,
  activeModules = [],
  selectedModule,
  onSelectModule,
  actionLoading = false,
}: NavbarProps) {
  const { data: session, status } = useSession();
  const router = useRouter();
  const pathname = usePathname();

  if (status === "loading") return null;

  return (
    <nav className="bg-gray-800 text-white p-4">
      <div className="max-w-7xl mx-auto flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div className="flex items-center space-x-4">
          <Link href="/" className="text-xl font-bold">RepairRadar</Link>
          {tenant && <span className="text-lg">| {tenant}</span>}
        </div>
        <div className="flex flex-wrap items-center space-x-4">
          {tenant && activeModules.length > 0 && (
            <>
              {activeModules.map((module) => (
                <Button
                  key={module.name}
                  variant={selectedModule?.name === module.name ? "default" : "ghost"}
                  onClick={() => onSelectModule?.(module)}
                  disabled={actionLoading}
                >
                  {module.name.charAt(0).toUpperCase() + module.name.slice(1).replace("-", " ")}
                </Button>
              ))}
            </>
          )}
          {session ? (
            <>
              {session.user.role === "SUPER_ADMIN" && (
                <Button variant="ghost" onClick={() => router.push("/admin")}>
                  Admin
                </Button>
              )}
              {pathname.startsWith("/[tenant]") && (
                <Button variant="ghost" onClick={() => router.push(`/${pathname.split("/")[1]}`)}>
                  Tenant Home
                </Button>
              )}
              <Button variant="ghost" onClick={() => signOut()}>
                Sign Out
              </Button>
            </>
          ) : (
            <Button variant="ghost" onClick={() => router.push("/auth/signin")}>
              Sign In
            </Button>
          )}
        </div>
      </div>
    </nav>
  );
}

// File: E:\Dev\websites\repairradar\src\components\SessionWrapper.tsx


"use client";
import { SessionProvider } from "next-auth/react";
import { Session } from "next-auth";
import { ReactNode } from "react";

export default function SessionWrapper({
  session,
  children,
}: {
  session: Session | null;
  children: ReactNode;
}) {
  return <SessionProvider session={session}>{children}</SessionProvider>;
}

// File: E:\Dev\websites\repairradar\src\components\ThemeWrapper.tsx


"use client";
import { ThemeProvider } from "next-themes";

export default function ThemeWrapper({ children }: { children: React.ReactNode }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      {children}
    </ThemeProvider>
  );
}

// File: E:\Dev\websites\repairradar\src\components\ui\badge.tsx


import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/70",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }


// File: E:\Dev\websites\repairradar\src\components\ui\button.tsx


import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


// File: E:\Dev\websites\repairradar\src\components\ui\calendar.tsx


"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}

export { Calendar }


// File: E:\Dev\websites\repairradar\src\components\ui\card.tsx


import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


// File: E:\Dev\websites\repairradar\src\components\ui\checkbox.tsx


"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }


// File: E:\Dev\websites\repairradar\src\components\ui\dialog.tsx


"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


// File: E:\Dev\websites\repairradar\src\components\ui\dropdown-menu.tsx


"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


// File: E:\Dev\websites\repairradar\src\components\ui\input.tsx


import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


// File: E:\Dev\websites\repairradar\src\components\ui\label.tsx


"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


// File: E:\Dev\websites\repairradar\src\components\ui\popover.tsx


"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


// File: E:\Dev\websites\repairradar\src\components\ui\select.tsx


"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


// File: E:\Dev\websites\repairradar\src\components\ui\sonner.tsx


"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }


// File: E:\Dev\websites\repairradar\src\components\ui\table.tsx


"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


// File: E:\Dev\websites\repairradar\src\lib\utils.ts


import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


// File: E:\Dev\websites\repairradar\src\middleware.ts


export const runtime = "nodejs";

import { NextRequest, NextResponse } from "next/server";

export async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  console.log("[Middleware] Requested path:", pathname);

  if (
    pathname.startsWith("/_next") ||
    pathname.startsWith("/api/auth") ||
    pathname === "/auth/signin" ||
    pathname === "/favicon.ico"
  ) {
    console.log("[Middleware] Bypassing for:", pathname);
    return NextResponse.next();
  }

  const authCookie = req.cookies.get("next-auth.session-token");
  console.log("[Middleware] Auth cookie:", authCookie ? "exists" : "not found");

  if (!authCookie) {
    if (pathname.startsWith("/api/")) {
      console.log("[Middleware] No auth cookie for API, returning unauthorized");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    } else {
      console.log("[Middleware] No auth cookie found, redirecting to /auth/signin");
      return NextResponse.redirect(new URL("/auth/signin", req.url));
    }
  }

  console.log("[Middleware] User authenticated, proceeding to:", pathname);
  return NextResponse.next();
}

export const config = {
  matcher: ["/((?!_next/static|_next/image|favicon.ico).*)"],
};


// File: E:\Dev\websites\repairradar\src\shared\lib\db.ts


import { PrismaClient } from "@prisma/client";
export const prisma = new PrismaClient();



// File: E:\Dev\websites\repairradar\src\shared\lib\hooks\index.ts


// src/shared/lib/hooks/index.ts
"use client";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import useSWR, { SWRConfiguration } from "swr";
import { toast } from "sonner";

const fetcher = async (url: string) => {
  const res = await fetch(url);
  if (!res.ok) {
    const errorText = await res.text();
    throw new Error(`Failed to fetch: ${errorText || res.statusText}`);
  }
  return res.json();
};

export function useTenantData<T>(
  module: string,
  tenant: string,
  options: SWRConfiguration = {}
) {
  const { status } = useSession();
  const router = useRouter();

  const url = `/api/${module}?subdomain=${tenant}`;
  const key = status === "authenticated" ? url : null;

  const { data, error, mutate, isLoading } = useSWR<T>(
    key,
    fetcher,
    {
      revalidateOnFocus: false,
      onError: (err) => {
        toast.error(err.message || `Failed to load ${module} data`);
        if (err.message.includes("Unauthorized")) {
          router.push("/auth/signin");
        }
      },
      ...options,
    }
  );

  return {
    data: Array.isArray(data) ? data : [], // Normalize response
    error,
    isLoading: isLoading || status === "loading",
    refetch: mutate,
  };
}


// File: E:\Dev\websites\repairradar\src\shared\modules\assets\api\route.ts


// src/shared/modules/assets/api/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/shared/lib/db';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

export async function GET(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  try {
    const url = new URL(req.url);
    const subdomain = url.searchParams.get('subdomain');
    const includeDeleted = url.searchParams.get('includeDeleted') === 'true';

    if (!subdomain) {
      return NextResponse.json({ error: 'Subdomain is required' }, { status: 400 });
    }
    const tenant = await prisma.tenants.findUnique({
      where: { subdomain, deletedAt: null },
    });
    if (!tenant) return NextResponse.json({ error: 'Tenant not found ' + subdomain }, { status: 404 });

    const assets = await prisma.asset.findMany({
      where: { tenant: tenant, deletedAt: includeDeleted ? undefined : null },
      orderBy: { name: 'asc' },
    });

    return NextResponse.json(assets);
  } catch (error) {
    console.error('Failed to fetch assets:', error);
    return NextResponse.json(
      { error: 'Failed to fetch assets' + error },
      { status: 500 }
    );
  }
}

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== 'ADMIN' && session.user.role !== 'SUPER_ADMIN')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const { name, location, subdomain } = await req.json();
    const tenant = await prisma.tenants.findUnique({ 
      where: { subdomain, deletedAt: null } 
    });
    if (!tenant) return NextResponse.json({ error: 'Tenant not found' }, { status: 404 });

    const asset = await prisma.asset.create({
      data: { 
        name,
        location: location || null,
        tenantId: tenant.id,
      },
    });

    return NextResponse.json(asset, { status: 201 });
  } catch (error) {
    console.error('Failed to create asset:', error);
    return NextResponse.json(
      { error: 'Failed to create asset' },
      { status: 500 }
    );
  }
}

export async function PUT(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== 'ADMIN' && session.user.role !== 'SUPER_ADMIN')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const action = req.headers.get('X-Action');
  const url = new URL(req.url);
  const id = url.searchParams.get('id');

  if (!id) return NextResponse.json({ error: 'Missing asset ID' }, { status: 400 });

  try {
    switch (action) {
      case 'updateAsset':
        const { name, location } = await req.json();
        const updatedAsset = await prisma.asset.update({
          where: { id },
          data: { name, location: location || null },
        });
        return NextResponse.json(updatedAsset);

      case 'deleteAsset':
        const deletedAsset = await prisma.asset.update({
          where: { id },
          data: { deletedAt: new Date() },
        });
        return NextResponse.json(deletedAsset);

      case 'restoreAsset':
        const restoredAsset = await prisma.asset.update({
          where: { id },
          data: { deletedAt: null },
        });
        return NextResponse.json(restoredAsset);

      default:
        return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }
  } catch (error) {
    console.error('Asset operation failed:', error);
    return NextResponse.json(
      { error: 'Asset operation failed' },
      { status: 500 }
    );
  }
}

export async function DELETE(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== 'ADMIN' && session.user.role !== 'SUPER_ADMIN')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const url = new URL(req.url);
  const id = url.searchParams.get('id');
  if (!id) return NextResponse.json({ error: 'Missing asset ID' }, { status: 400 });

  try {
    await prisma.asset.delete({ where: { id } });
    return NextResponse.json({ message: 'Asset permanently deleted' });
  } catch (error) {
    console.error('Failed to delete asset:', error);
    return NextResponse.json(
      { error: 'Failed to delete asset' },
      { status: 500 }
    );
  }
}

// File: E:\Dev\websites\repairradar\src\shared\modules\assets\components\AssetsPage.tsx


"use client";
import { useState, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { EditDialog } from "@/components/EditDialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { toast } from "sonner";
import { Archive, Edit, Loader2, Plus, RefreshCw, Search, Trash2 } from "lucide-react";
import { Asset } from "@prisma/client";
import { useTenantData } from "@/shared/lib/hooks";

export default function AssetsPage({ tenant }: { tenant: string }) {
  const { data: assets = [], isLoading, refetch } = useTenantData<Asset[]>("assets", tenant);
  
  // State management
  const [searchTerm, setSearchTerm] = useState("");
  const [newAsset, setNewAsset] = useState({ name: "", location: "" });
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [currentAsset, setCurrentAsset] = useState<Asset | null>(null);
  const [isCreating, setIsCreating] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Filter assets based on search term
  const filteredAssets = useCallback(() => {
    const searchTermLower = searchTerm.toLowerCase();
    return assets.filter(asset => 
      asset.name.toLowerCase().includes(searchTermLower) ||
      (asset.location?.toLowerCase().includes(searchTermLower) ?? false)
    );
  }, [assets, searchTerm]);

  // Handle data refresh
  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await refetch();
    } catch (error) {
      toast.error('Failed to refresh assets ' + error);
    } finally {
      setIsRefreshing(false);
    }
  }, [refetch]);

  // Handle asset creation
  const handleCreateAsset = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newAsset.name.trim()) {
      toast.error('Asset name is required');
      return;
    }

    try {
      const res = await fetch('/api/assets', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          subdomain: tenant, 
          name: newAsset.name.trim(), 
          location: newAsset.location.trim() 
        }),
      });

      if (!res.ok) throw new Error(await res.text());

      setNewAsset({ name: '', location: '' });
      await handleRefresh();
      toast.success('Asset created successfully');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to create asset');
    }
  };

  // Handle asset deletion
  const handleDeleteAsset = async (id: string) => {
    if (!confirm('Are you sure you want to archive this asset?')) return;

    try {
      const res = await fetch(`/api/assets?id=${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Action': 'deleteAsset',
        },
      });

      if (!res.ok) throw new Error(await res.text());
      
      await handleRefresh();
      toast.success('Asset archived');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to archive asset');
    }
  };

  // Handle asset restoration
  const handleRestoreAsset = async (id: string) => {
    try {
      const res = await fetch(`/api/assets?id=${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Action': 'restoreAsset',
        },
      });

      if (!res.ok) throw new Error(await res.text());
      
      await handleRefresh();
      toast.success('Asset restored');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to restore asset');
    }
  };

  // Handle asset updates
  const handleUpdateAsset = async (id: string, updates: Partial<Asset>) => {
    try {
      const res = await fetch(`/api/assets?id=${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Action': 'updateAsset',
        },
        body: JSON.stringify(updates),
      });

      if (!res.ok) throw new Error(await res.text());
      
      await handleRefresh();
      setEditDialogOpen(false);
      toast.success('Asset updated');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to update asset');
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold">Assets</h1>
          <p className="text-muted-foreground">Manage your organizations physical assets</p>
        </div>
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleRefresh}
            disabled={isRefreshing}
          >
            {isRefreshing ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Refresh
          </Button>
          <Button onClick={() => setIsCreating(!isCreating)}>
            <Plus className="h-4 w-4 mr-2" />
            New Asset
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader className="pb-0">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
              <CardTitle>Asset Inventory</CardTitle>
              <CardDescription>
                {filteredAssets().length} {filteredAssets().length === 1 ? 'asset' : 'assets'} found
              </CardDescription>
            </div>
            <div className="relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search assets..."
                className="pl-9"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
              />
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {isCreating && (
            <form onSubmit={handleCreateAsset} className="mb-6 p-4 border rounded-lg bg-muted/50">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Asset Name *
                  </label>
                  <Input
                    value={newAsset.name}
                    onChange={(e) => setNewAsset({...newAsset, name: e.target.value})}
                    placeholder="e.g., Laptop, Printer"
                    required
                  />
                </div>
                <div>
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Location
                  </label>
                  <Input
                    value={newAsset.location}
                    onChange={(e) => setNewAsset({...newAsset, location: e.target.value})}
                    placeholder="e.g., Room 101, Warehouse"
                  />
                </div>
                <div className="flex items-end gap-2">
                  <Button 
                    type="submit" 
                    disabled={!newAsset.name.trim()}
                  >
                    {!newAsset.name.trim() ? (
                      <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    ) : (
                      <Plus className="h-4 w-4 mr-2" />
                    )}
                    Add Asset
                  </Button>
                  <Button 
                    variant="outline" 
                    type="button"
                    onClick={() => setIsCreating(false)}
                  >
                    Cancel
                  </Button>
                </div>
              </div>
            </form>
          )}

          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Name</TableHead>
                  <TableHead>Location</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredAssets().length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={4} className="h-24 text-center">
                      {searchTerm ? 'No matching assets found' : 'No assets available'}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredAssets().map((asset) => (
                    <TableRow key={asset.id}>
                      <TableCell className="font-medium">
                        {asset.name}
                      </TableCell>
                      <TableCell>
                        {asset.location || (
                          <span className="text-muted-foreground">Not specified</span>
                        )}
                      </TableCell>
                      <TableCell>
                        <Badge variant={asset.deletedAt ? 'destructive' : 'default'}>
                          {asset.deletedAt ? 'Archived' : 'Active'}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-right">
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="sm">
                              Actions
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            {asset.deletedAt ? (
                              <DropdownMenuItem 
                                onClick={() => handleRestoreAsset(asset.id)}
                                className="text-green-600"
                              >
                                <Archive className="h-4 w-4 mr-2" />
                                Restore
                              </DropdownMenuItem>
                            ) : (
                              <>
                                <DropdownMenuItem 
                                  onClick={() => {
                                    setCurrentAsset(asset);
                                    setEditDialogOpen(true);
                                  }}
                                >
                                  <Edit className="h-4 w-4 mr-2" />
                                  Edit
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                  onClick={() => handleDeleteAsset(asset.id)}
                                  className="text-red-600"
                                >
                                  <Trash2 className="h-4 w-4 mr-2" />
                                  Archive
                                </DropdownMenuItem>
                              </>
                            )}
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
      <EditDialog
        open={editDialogOpen}
        onOpenChange={(open) => {
          setEditDialogOpen(open);
          if (!open) setCurrentAsset(null);
        }}
        title="Edit Asset"
        description="Update the asset details"
        initialData={{
          name: currentAsset?.name || '',
          location: currentAsset?.location || '',
          status: currentAsset?.deletedAt ? 'ARCHIVED' : 'ACTIVE'
        }}
        fields={[
          {
            name: 'name',
            label: 'Asset Name',
            type: 'text',
            required: true
          },
          {
            name: 'location',
            label: 'Location',
            type: 'text'
          },
          {
            name: 'status',
            label: 'Status',
            type: 'select',
            options: [
              { value: 'ACTIVE', label: 'Active' },
              { value: 'ARCHIVED', label: 'Archived' }
            ]
          }
        ]}
        onSubmit={(data) => handleUpdateAsset(currentAsset?.id || "", data)
        }
      />
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\shared\modules\assets\types.ts


// src/shared/modules/assets/types.ts
export interface AssetWithDeleted {
  id: string;
  name: string;
  tenantId: string;
  location: string | null;
  createdAt: string;
  updatedAt: string;
  deletedAt: string | null;
}

export interface CreateAssetInput {
  name: string;
  location?: string;
  tenantId: string;
}

export interface UpdateAssetInput {
  id: string;
  name?: string;
  location?: string | null;
}

// File: E:\Dev\websites\repairradar\src\shared\modules\calls\api\route.ts


// src/shared/modules/calls/api/route.ts
import { NextResponse } from 'next/server';
import { prisma } from '@/shared/lib/db';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { CallStatus } from '@prisma/client';

export async function GET(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  try {
    const url = new URL(req.url);
    const subdomain = url.searchParams.get('subdomain');
    const where: any = {};
    if (subdomain) {
      const tenant = await prisma.tenants.findUnique({
        where: { subdomain, deletedAt: null },
      });
      if (!tenant) return NextResponse.json({ error: 'Tenant not found' }, { status: 404 });
      where.tenantId = tenant.id;
    }

    const calls = await prisma.call.findMany({
      where,
      include: {
        asset: true,
        reportedBy: { select: { 
          id: true, 
          email: true, 
          //name: true 
        } 
      }
      },
      orderBy: { callTime: 'desc' },
    });

    return NextResponse.json(calls);
  } catch (error) {
    console.error('Failed to fetch calls:', error);
    return NextResponse.json(
      { error: 'Failed to fetch calls' },
      { status: 500 }
    );
  }
}

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  try {
    const { tenantId: subdomain, issue, assetId } = await req.json();
    const tenant = await prisma.tenants.findUnique({ 
      where: { subdomain, deletedAt: null } 
    });
    if (!tenant) return NextResponse.json({ error: 'Tenant not found' }, { status: 404 });

    const asset = await prisma.asset.findUnique({ 
      where: { id: assetId, deletedAt: null } 
    });
    if (!asset || asset.tenantId !== tenant.id) {
      return NextResponse.json({ error: 'Invalid asset' }, { status: 400 });
    }

    const call = await prisma.call.create({
      data: { 
        issue,
        status: CallStatus.OPEN,
        tenantId: tenant.id,
        assetId,
        reportedById: session.user.id,
        callTime: new Date(),
      },
      include: { asset: true, reportedBy: true },
    });

    return NextResponse.json(call, { status: 201 });
  } catch (error) {
    console.error('Failed to create call:', error);
    return NextResponse.json(
      { error: 'Failed to create call' },
      { status: 500 }
    );
  }
}

export async function PUT(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== 'ADMIN' && session.user.role !== 'SUPER_ADMIN')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const action = req.headers.get('X-Action');
  const url = new URL(req.url);
  const id = url.searchParams.get('id');

  if (!id) return NextResponse.json({ error: 'Missing call ID' }, { status: 400 });

  try {
    switch (action) {
      case 'updateCall':
        const { status } = await req.json();
        const updatedCall = await prisma.call.update({
          where: { id },
          data: { status },
          include: { asset: true, reportedBy: true },
        });
        return NextResponse.json(updatedCall);

      case 'deleteCall':
        const deletedCall = await prisma.call.update({
          where: { id },
          data: { deletedAt: new Date() },
          include: { asset: true, reportedBy: true },
        });
        return NextResponse.json(deletedCall);

      case 'restoreCall':
        const restoredCall = await prisma.call.update({
          where: { id },
          data: { deletedAt: null },
          include: { asset: true, reportedBy: true },
        });
        return NextResponse.json(restoredCall);

      default:
        return NextResponse.json({ error: 'Invalid action' }, { status: 400 });
    }
  } catch (error) {
    console.error('Call operation failed:', error);
    return NextResponse.json(
      { error: 'Call operation failed' },
      { status: 500 }
    );
  }
}

export async function DELETE(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== 'ADMIN' && session.user.role !== 'SUPER_ADMIN')) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const url = new URL(req.url);
  const id = url.searchParams.get('id');
  if (!id) return NextResponse.json({ error: 'Missing call ID' }, { status: 400 });

  try {
    await prisma.call.delete({ where: { id } });
    return NextResponse.json({ message: 'Call permanently deleted' });
  } catch (error) {
    console.error('Failed to delete call:', error);
    return NextResponse.json(
      { error: 'Failed to delete call' },
      { status: 500 }
    );
  }
}

// File: E:\Dev\websites\repairradar\src\shared\modules\calls\components\CallsPage.tsx


"use client";
import { useState, useEffect, useCallback } from "react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { EditDialog } from "@/components/EditDialog";
import { toast } from "sonner";
import { Check, ChevronDown, Edit, Loader2, Phone, Plus, RefreshCw, Search, Trash2 } from "lucide-react";
import { Asset, Call } from "@prisma/client";
import { useTenantData } from "@/shared/lib/hooks";

export default function CallsPage({ tenant }: { tenant: string }) {
  const { data: calls = [], isLoading: callsLoading, refetch: refetchCalls } = useTenantData<Call[]>("calls", tenant);
  const { data: assets = [], isLoading: assetsLoading, refetch: refetchAssets } = useTenantData<Asset[]>("assets", tenant);
  const { status } = useSession();
  const router = useRouter();

  // State management
  const [searchTerm, setSearchTerm] = useState("");
  const [sortField, setSortField] = useState<"callTime" | "status">("callTime");
  const [statusFilter, setStatusFilter] = useState<"all" | Call["status"]>("all");
  const [newCall, setNewCall] = useState({ issue: "", assetId: "" });
  const [isCreating, setIsCreating] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [currentCall, setCurrentCall] = useState<Call | null>(null);
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Filter and sort calls
  const filteredCalls = useCallback(() => {
    return calls
      .filter(call => {
        const matchesSearch = searchTerm === "" || 
          call.issue.toLowerCase().includes(searchTerm.toLowerCase()) ||
          assets.some(asset => 
            asset.id === call.assetId && 
            asset.name.toLowerCase().includes(searchTerm.toLowerCase())
          );
        
        const matchesStatus = statusFilter === 'all' || call.status === statusFilter;
        return matchesSearch && matchesStatus;
      })
      .sort((a, b) => {
        if (sortField === 'callTime') {
          return new Date(b.callTime).getTime() - new Date(a.callTime).getTime();
        }
        return a.status.localeCompare(b.status);
      });
  }, [calls, assets, searchTerm, statusFilter, sortField]);

  // Handle call status update
  const handleUpdateSubmit = useCallback(async (data: Partial<Call>) => {
    if (!currentCall) return;
    
    try {
      const res = await fetch(`/api/calls?id=${currentCall.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Action': 'updateCall',
        },
        body: JSON.stringify(data),
      });

      if (!res.ok) {
        throw new Error(await res.text());
      }

      toast.success('Call updated successfully');
      await refetchCalls();
      setEditDialogOpen(false);
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to update call');
    }
  }, [currentCall, refetchCalls]);

  // Handle data refresh
  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await Promise.all([refetchCalls(), refetchAssets()]);
    } catch (error) {
      toast.error('Failed to refresh data ' + error);
    } finally {
      setIsRefreshing(false);
    }
  }, [refetchCalls, refetchAssets]);

  // Handle call creation
  const handleCreateCall = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newCall.issue || !newCall.assetId) {
      toast.error('Issue and asset are required');
      return;
    }

    try {
      const res = await fetch('/api/calls', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          tenantId: tenant, 
          issue: newCall.issue, 
          assetId: newCall.assetId 
        }),
      });

      if (!res.ok) throw new Error(await res.text());
      
      setNewCall({ issue: '', assetId: '' });
      setIsCreating(false);
      await handleRefresh();
      toast.success('Call created successfully');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to create call');
    }
  };

  // Handle call deletion
  const handleDeleteCall = async (id: string) => {
    if (!confirm('Are you sure you want to delete this call?')) return;
    
    try {
      const res = await fetch(`/api/calls?id=${id}`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
      });

      if (!res.ok) throw new Error(await res.text());
      
      await handleRefresh();
      toast.success('Call deleted successfully');
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Failed to delete call');
    }
  };

  // Handle session and data loading
  useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/auth/signin');
    } else if (status === 'authenticated') {
      handleRefresh();
    }
  }, [status, router, handleRefresh]);

  // Loading state
  if (status === 'loading' || assetsLoading || callsLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold">Service Calls</h1>
          <p className="text-muted-foreground">Manage incoming service requests</p>
        </div>
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleRefresh}
            disabled={isRefreshing}
          >
            {isRefreshing ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Refresh
          </Button>
          <Button onClick={() => setIsCreating(!isCreating)}>
            <Plus className="h-4 w-4 mr-2" />
            New Call
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader className="pb-0">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
              <CardTitle>Call Log</CardTitle>
              <CardDescription>
                {filteredCalls().length} {filteredCalls().length === 1 ? 'call' : 'calls'} found
              </CardDescription>
            </div>
            <div className="flex flex-col md:flex-row gap-3">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search calls..."
                  className="pl-9"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
              <Select 
                value={sortField} 
                onValueChange={(val) => setSortField(val as 'callTime' | 'status')}
              >
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Sort by" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="callTime">Call Time</SelectItem>
                  <SelectItem value="status">Status</SelectItem>
                </SelectContent>
              </Select>
              <Select 
                value={statusFilter} 
                onValueChange={(val) => setStatusFilter(val as 'all' | Call["status"])}
              >
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Filter status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Statuses</SelectItem>
                  <SelectItem value="OPEN">Open</SelectItem>
                  <SelectItem value="IN_PROGRESS">In Progress</SelectItem>
                  <SelectItem value="CLOSED">Closed</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {isCreating && (
            <form onSubmit={handleCreateCall} className="mb-6 p-4 border rounded-lg bg-muted/50">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Issue Description *
                  </label>
                  <Input
                    value={newCall.issue}
                    onChange={(e) => setNewCall({...newCall, issue: e.target.value})}
                    placeholder="Describe the issue..."
                    required
                  />
                </div>
                <div>
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Asset *
                  </label>
                  <Select 
                    value={newCall.assetId}
                    onValueChange={(value) => setNewCall({...newCall, assetId: value})}
                    required
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select an asset" />
                    </SelectTrigger>
                    <SelectContent>
                      {assets.map((asset) => (
                        <SelectItem key={asset.id} value={asset.id}>
                          {asset.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
                <div className="flex items-end gap-2">
                  <Button type="submit" disabled={!newCall.issue || !newCall.assetId}>
                    <Phone className="h-4 w-4 mr-2" />
                    Log Call
                  </Button>
                  <Button 
                    variant="outline" 
                    type="button"
                    onClick={() => setIsCreating(false)}
                  >
                    Cancel
                  </Button>
                </div>
              </div>
            </form>
          )}

          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Issue</TableHead>
                  <TableHead>Asset</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Call Time</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredCalls().length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={5} className="h-24 text-center">
                      {searchTerm ? 'No matching calls found' : 'No calls available'}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredCalls().map((call) => {
                    const asset = assets.find(a => a.id === call.assetId);
                    return (
                      <TableRow key={call.id}>
                        <TableCell className="font-medium">
                          {call.issue}
                        </TableCell>
                        <TableCell>
                          {asset?.name || (
                            <span className="text-muted-foreground">No asset</span>
                          )}
                        </TableCell>
                        <TableCell>
                          <Badge variant={
                            call.status === 'CLOSED' ? 'destructive' :
                            call.status === 'IN_PROGRESS' ? 'secondary' : 'default'
                          }>
                            {call.status === 'OPEN' && <Phone className="h-3 w-3 mr-1" />}
                            {call.status === 'IN_PROGRESS' && <Loader2 className="h-3 w-3 mr-1 animate-spin" />}
                            {call.status === 'CLOSED' && <Check className="h-3 w-3 mr-1" />}
                            {call.status.split('_').join(' ')}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          {new Date(call.callTime).toLocaleString()}
                        </TableCell>
                        <TableCell className="text-right">
                          <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                              <Button variant="ghost" size="sm">
                                Actions <ChevronDown className="ml-1 h-4 w-4" />
                              </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                              <DropdownMenuItem onClick={() => {
                                setCurrentCall(call);
                                setEditDialogOpen(true);
                              }}>
                                <Edit className="h-4 w-4 mr-2" />
                                Update Status
                              </DropdownMenuItem>
                              <DropdownMenuItem
                                onClick={() => handleDeleteCall(call.id)}
                                className="text-red-600"
                              >
                                <Trash2 className="h-4 w-4 mr-2" />
                                Delete
                              </DropdownMenuItem>
                            </DropdownMenuContent>
                          </DropdownMenu>
                        </TableCell>
                      </TableRow>
                    );
                  })
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>
      
      <EditDialog
        open={editDialogOpen}
        onOpenChange={(open) => {
          setEditDialogOpen(open);
          if (!open) setCurrentCall(null);
        }}
        title="Update Call Status"
        description="Change the status of this service call"
        initialData={{
          status: currentCall?.status || 'OPEN',
          id: currentCall?.id || '',
        }}
        fields={[
          {
            name: 'status',
            label: 'Status',
            type: 'select',
            options: [
              { value: 'OPEN', label: 'Open' },
              { value: 'IN_PROGRESS', label: 'In Progress' },
              { value: 'CLOSED', label: 'Closed' }
            ]
          }
        ]}
        onSubmit={handleUpdateSubmit}
      />
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\shared\modules\dashboard\api\route.ts


import { NextResponse } from "next/server";
import { ModuleManager } from "@/shared/modules/moduleManager";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const tenant = searchParams.get("tenant");
  if (!tenant) return NextResponse.json({ error: "Tenant required" }, { status: 400 });

  const res = await fetch(`http://localhost:3000/api/tenants?subdomain=${tenant}`);
  if (!res.ok) return NextResponse.json({ error: "Config fetch failed" }, { status: 500 });
  const { config } = await res.json();

  const modules = ModuleManager.getActiveModules(config)
    .filter((mod) => mod.name !== "dashboard");

  const metrics = await Promise.all(
    modules.map(async (mod) => {
      const modRes = await fetch(`http://localhost:3000${mod.apiRoute}?tenant=${tenant}`);
      return { [mod.name]: modRes.ok ? await modRes.json() : null };
    })
  );

  return NextResponse.json({
    tenant,
    metrics: Object.assign({}, ...metrics),
  });
}

// File: E:\Dev\websites\repairradar\src\shared\modules\dashboard\components\DashboardPage.tsx


"use client";
import { useEffect, useState } from "react";
import { ModuleManager } from "@/shared/modules/moduleManager";
import type { DashboardPageProps, ModuleMetrics, LoadedModule } from "../types";

/**
 * DashboardPage fetches and displays metrics for all active modules for a tenant.
 * @param {string} tenant - Tenant identifier
 */
export default function DashboardPage({ tenant }: DashboardPageProps) {
  const [modules, setModules] = useState<LoadedModule[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadModulesAndData = async () => {
      try {
        // Fetch tenant config to get active modules
        const res = await fetch(`/api/tenants?subdomain=${tenant}`);
        if (!res.ok) throw new Error(`Failed to fetch tenant config: ${res.statusText}`);
        const data = await res.json();
        if (!data.config) throw new Error("Tenant config not found");

        // Get active modules, excluding dashboard
        const rawModules = ModuleManager.getActiveModules(data.config)
          .filter((mod) => mod.name !== "dashboard");

        // Fetch metrics for each module using tenant-specific API calls
        const loadedModules = await Promise.all(
          rawModules.map(async (mod) => {
            try {
              const metricsRes = await fetch(`/api/${mod.name}?tenant=${tenant}`); // No change needed
              const metrics: ModuleMetrics = metricsRes.ok ? await metricsRes.json() : {};
              return { name: mod.name, apiRoute: mod.apiRoute, metrics };
            } catch (err) {
              console.warn(`Failed to fetch metrics for ${mod.name}:`, err);
              return { name: mod.name, apiRoute: mod.apiRoute, metrics: null };
            }
          })
        );
        setModules(loadedModules);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Unknown error");
      } finally {
        setLoading(false);
      }
    };
    loadModulesAndData();
  }, [tenant]);

  if (loading) return <div className="p-4">Loading dashboard...</div>;
  if (error) return <div className="p-4 text-red-500">Error: {error}</div>;

  return (
    <div className="space-y-6">
      <h2 className="text-xl font-semibold">Dashboard Metrics for {tenant}</h2>
      {modules.length === 0 ? (
        <p className="text-gray-500">No active modules to display.</p>
      ) : (
        <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {modules.map((module) => (
            <div key={module.name} className="border p-4 rounded">
              <h3 className="font-bold mb-2">
                {module.name.charAt(0).toUpperCase() + module.name.slice(1).replace("-", " ")}
              </h3>
              {module.metrics && Object.keys(module.metrics).length > 0 ? (
                <dl className="space-y-1">
                  {Object.entries(module.metrics).map(([key, value]) => (
                    <div key={key} className="flex justify-between">
                      <dt className="text-gray-600">
                        {key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, " $1")}:
                      </dt>
                      <dd className="font-medium">{value ?? "N/A"}</dd>
                    </div>
                  ))}
                </dl>
              ) : (
                <p className="text-gray-500">No metrics available</p>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

// File: E:\Dev\websites\repairradar\src\shared\modules\dashboard\components\ModuleSummary.tsx


import { memo, Suspense } from "react";


/**
 * Renders a dynamically loaded module component with loading fallback.
 * @param {string} name - Module name
 * @param {React.ComponentType<{ tenant: string }>} Component - Module component
 * @param {string} tenant - Tenant identifier
 */
interface ModuleSummaryProps {
  name: string | "test";
  Component: React.ComponentType<{ tenant: string }>;
  tenant: string;
}

// eslint-disable-next-line react/display-name
export const ModuleSummary = memo(({ name, Component, tenant }: ModuleSummaryProps) => (
  <Suspense fallback={<div>Loading ...</div>}>
    <div className="border p-4 rounded">
      <h3 className="font-bold">{name}</h3>
      <Component tenant={tenant} />
    </div>
  </Suspense>
));


// File: E:\Dev\websites\repairradar\src\shared\modules\dashboard\types.ts


import { RawModule } from "@/shared/modules/moduleManager";

/** Props for DashboardPage */
export interface DashboardPageProps {
  tenant: string;
}

/** Module summary data */
export interface ModuleMetrics {
  total?: number;
  active?: number;
  pending?: number;
  [key: string]: number | undefined;
}

/** Loaded module with metrics */
export interface LoadedModule {
  name: string;
  apiRoute: string;
  metrics: ModuleMetrics | null;
}

// File: E:\Dev\websites\repairradar\src\shared\modules\moduleImports.generated.ts


// Auto-generated by scripts/generateModuleImports.js
export const moduleImports: Record<string, () => Promise<{ default: React.ComponentType<{ tenant: string }> }>> = {
  "assets": () => import("@/shared/modules/assets/components/AssetsPage"),
  "calls": () => import("@/shared/modules/calls/components/CallsPage"),
  "dashboard": () => import("@/shared/modules/dashboard/components/DashboardPage"),
  "preventative-maintenance": () => import("@/shared/modules/preventative-maintenance/components/PreventativeMaintenancePage"),
  "work-orders": () => import("@/shared/modules/work-orders/components/WorkOrdersPage"),
};


// File: E:\Dev\websites\repairradar\src\shared\modules\moduleManager.ts


// src/shared/modules/moduleManager.ts
import { moduleImports } from "./moduleImports.generated";
import { TenantConfig } from "./types";

export interface RawModule {
  name: string;
  component: () => Promise<{ default: React.ComponentType<{ tenant: string }> }>;
  apiRoute: string;
}

export class ModuleManager {
  static getActiveModules(config: TenantConfig): RawModule[] {
    return Object.keys(config.modules)
      .filter((key) => config.modules[key] && moduleImports[key])
      .map((key) => ({
        name: key,
        component: moduleImports[key],
        apiRoute: `/api/${key}`,
      }));
  }

  static getAllModules(): string[] {
    return Object.keys(moduleImports);
  }
}

// File: E:\Dev\websites\repairradar\src\shared\modules\preventative-maintenance\api\route.ts


// src/shared/modules/preventative-maintenance/api/route.ts
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/shared/lib/db"; // Assuming db.ts exports Prisma client
import { z } from "zod";
import { getServerSession } from "next-auth";
import { CreateMaintenanceInput } from "../types";

const schema = z.object({
  description: z.string().min(5, "Description must be at least 5 characters"),
  recurrence: z.object({
    type: z.enum(["daily", "weekly", "monthly"]),
    interval: z.number().int().min(1),
  }),
  nextRun: z.string().datetime(),
  lastRun: z.string().datetime().optional(),
  status: z.enum(["SCHEDULED", "IN_PROGRESS", "COMPLETED", "OVERDUE"]).optional(),
  priority: z.enum(["LOW", "MEDIUM", "HIGH"]).optional(),
  assignedToId: z.string().uuid().optional(),
  assetIds: z.array(z.string().uuid()).min(1, "At least one asset is required"),
  tenantId: z.string().uuid(),
});

export async function GET(req: NextRequest) {
  const session = await getServerSession();
  const { searchParams } = new URL(req.url);
  const tenantId = searchParams.get("tenantId");
  const status = searchParams.get("status") as "SCHEDULED" | "IN_PROGRESS" | "COMPLETED" | "OVERDUE" | null;
  const skip = parseInt(searchParams.get("skip") || "0");
  const take = parseInt(searchParams.get("take") || "20");

  if (!tenantId || (session?.user.role !== "SUPER_ADMIN" && session?.user.tenantId !== tenantId)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const filters = {
    tenantId,
    deletedAt: null,
    ...(status && { status }),
  };

  const schedules = await prisma.maintenanceSchedule.findMany({
    where: filters,
    include: {
      assets: { include: { asset: { select: { id: true, name: true } } } },
      assignedTo: { select: { id: true, email: true } },
    },
    orderBy: { nextRun: "asc" },
    skip,
    take,
  });

  return NextResponse.json({ data: schedules });
}
export async function POST(req: NextRequest) {
  const session = await getServerSession();
  const body = schema.parse(await req.json()) as CreateMaintenanceInput;
  const { assetIds, ...scheduleData } = body;

  if (session?.user.role !== "SUPER_ADMIN" && session?.user.tenantId !== body.tenantId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const validAssets = await prisma.asset.findMany({
    where: { id: { in: assetIds }, tenantId: body.tenantId, deletedAt: null },
  });
  if (validAssets.length !== assetIds.length) {
    return NextResponse.json({ error: "Invalid or unauthorized assets" }, { status: 400 });
  }

  const schedule = await prisma.maintenanceSchedule.create({
    data: {
      ...scheduleData,
      status: scheduleData.status || "SCHEDULED",
      priority: scheduleData.priority || "MEDIUM",
      assets: { create: assetIds.map(assetId => ({ assetId })) },
      createdAt: new Date(),
      updatedAt: new Date(),
    },
    include: {
      assets: { include: { asset: { select: { id: true, name: true } } } },
      assignedTo: { select: { id: true, email: true } },
    },
  });

  return NextResponse.json(schedule, { status: 201 });
}

export async function PUT(req: NextRequest) {
  const session = await getServerSession();
  const body = schema.partial().extend({ id: z.string().uuid() }).parse(await req.json());
  const { id, assetIds, ...updateData } = body;

  const existing = await prisma.maintenanceSchedule.findUnique({
    where: { id, deletedAt: null },
    include: { assets: true },
  });
  if (!existing || (session?.user.role !== "SUPER_ADMIN" && session?.user.tenantId !== existing.tenantId)) {
    return NextResponse.json({ error: "Unauthorized or not found" }, { status: 404 });
  }

  const schedule = await prisma.maintenanceSchedule.update({
    where: { id },
    data: {
      ...updateData,
      ...(assetIds && {
        assets: {
          deleteMany: {},
          create: assetIds.map(assetId => ({ assetId })),
        },
      }),
      updatedAt: new Date(),
    },
    include: {
      assets: { include: { asset: { select: { id: true, name: true } } } },
      assignedTo: { select: { id: true, email: true } },
    },
  });

  return NextResponse.json(schedule);
}

export async function DELETE(req: NextRequest) {
  const session = await getServerSession();
  const { searchParams } = new URL(req.url);
  const id = searchParams.get("id");

  if (!id) return NextResponse.json({ error: "ID required" }, { status: 400 });

  const existing = await prisma.maintenanceSchedule.findUnique({
    where: { id, deletedAt: null },
  });
  if (!existing || (session?.user.role !== "SUPER_ADMIN" && session?.user.tenantId !== existing.tenantId)) {
    return NextResponse.json({ error: "Unauthorized or not found" }, { status: 404 });
  }

  const deleted = await prisma.maintenanceSchedule.update({
    where: { id },
    data: { deletedAt: new Date() },
  });

  return NextResponse.json({ message: "Schedule deleted", data: deleted });
}

// File: E:\Dev\websites\repairradar\src\shared\modules\preventative-maintenance\components\PreventativeMaintenancePage.tsx


"use client";
import { useState, useEffect } from "react";
import { useTenantData } from "@/shared/lib/hooks";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
} from "@/components/ui/select";
import { toast } from "sonner";
import ClientToaster from "@/components/ClientToaster";
import { MaintenanceSchedule } from "../types";
import { Loader2 } from "lucide-react";
import { useSession } from "next-auth/react";
import router from "next/router";

export default function PreventativeMaintenancePage({ tenant }: { tenant: string }) {
  const { data: schedules, isLoading, refetch } = useTenantData<MaintenanceSchedule[]>("preventative-maintenance", tenant);
  const { status } = useSession();
  const [formData, setFormData] = useState({
    description: "",
    recurrence: { type: "monthly", interval: 1 },
    nextRun: new Date().toISOString().slice(0, 16),
    assetIds: [],
  });

  useEffect(() => {
    if (status === 'authenticated') {
      try {
        Promise.all([refetch()])
      } catch (error) {
        toast.error(`Failed to create call: ${error}`);
      }
    }
  }, [status, refetch]);

  if (status === 'loading' || isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  if (status === 'unauthenticated') {
    router.push('/auth/signin');
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const res = await fetch(`/api/preventative-maintenance`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ...formData, tenantId: tenant }),
    });
    if (res.ok) {
      refetch();
      setFormData({ description: "", recurrence: { type: "monthly", interval: 1 }, nextRun: new Date().toISOString().slice(0, 16), assetIds: [] });
      toast.success("Maintenance scheduled");
    } else {
      toast.error("Failed to schedule maintenance");
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <Input
          value={formData.description}
          onChange={(e) => setFormData({ ...formData, description: e.target.value })}
          placeholder="Description"
        />
        <Select
          value={formData.recurrence.type}
          onValueChange={(value) => setFormData({ ...formData, recurrence: { ...formData.recurrence, type: value } })}
        >
          <option value="daily">Daily</option>
          <option value="weekly">Weekly</option>
          <option value="monthly">Monthly</option>
        </Select>
        <Input
          type="number"
          value={formData.recurrence.interval}
          onChange={(e) => setFormData({ ...formData, recurrence: { ...formData.recurrence, interval: parseInt(e.target.value) } })}
          placeholder="Interval"
        />
        <Input
          type="datetime-local"
          value={formData.nextRun}
          onChange={(e) => setFormData({ ...formData, nextRun: e.target.value })}
        />
        <Button type="submit">Schedule</Button>
      </form>
      <ul>
        {schedules && schedules && schedules.map((item: MaintenanceSchedule) => (
          <li key={item.id}>
            {item.description} - Next Run: {isLoading ? new Date(item.nextRun).toLocaleString() : item.nextRun}
          </li>
        ))}
      </ul>
      <ClientToaster />
    </div>
    
  );
}

// File: E:\Dev\websites\repairradar\src\shared\modules\preventative-maintenance\types.ts


// src/shared/modules/preventative-maintenance/types.ts
export interface MaintenanceSchedule {
    id: string;
    tenantId: string;
    description: string;
    recurrence: { type: "daily" | "weekly" | "monthly"; interval: number };
    nextRun: string;
    lastRun?: string | null;
    status: "SCHEDULED" | "IN_PROGRESS" | "COMPLETED" | "OVERDUE";
    priority: "LOW" | "MEDIUM" | "HIGH";
    assignedToId?: string | null;
    assignedTo?: { id: string; email: string } | null;
    assets: { assetId: string; asset: { name: string } }[];
    createdAt: string;
    updatedAt: string;
    deletedAt?: string | null;
  }
  
  export interface CreateMaintenanceInput {
    description: string;
    recurrence: { type: "daily" | "weekly" | "monthly"; interval: number };
    nextRun: string;
    lastRun?: string;
    status?: "SCHEDULED" | "IN_PROGRESS" | "COMPLETED" | "OVERDUE";
    priority?: "LOW" | "MEDIUM" | "HIGH";
    assignedToId?: string;
    assetIds: string[];
    tenantId: string;
  }

// File: E:\Dev\websites\repairradar\src\shared\modules\types.ts


// src/shared/modules/types.ts
import { WorkOrderPriority, WorkOrderStatus } from "@prisma/client";
import { ComponentType } from "react";

export * from "@prisma/client";

export type ModuleConfig = Record<string, boolean>;

export interface TenantConfig {
  id: string;
  tenantId: string;
  modules: { [key: string]: boolean };
  theme?: { primaryColor?: string; logoUrl?: string };
  createdAt: Date;
  updatedAt: Date;
  deletedAt: Date | null;
}

export interface CreateCallInput {
  tenantId: string;
  issue: string;
  assetId: string;
}

export interface CreateWorkOrderInput {
  tenantId: string;
  description: string;
  assetIds: string[];
  priority?: WorkOrderPriority;
  dueDate?: string;
  assignedToId?: string;
  notes?: string[];
}

export interface UpdateWorkOrderInput {
  id: string;
  status?: WorkOrderStatus;
  assignedToId?: string | null;
  newNotes?: string[];
  assetIds?: string[];
}

export interface Module {
  name: string;
  apiRoute: string;
  component: ComponentType<{ tenant: string }>;
}

export interface RawModule {
  name: string;
  component: () => Promise<{ default: ComponentType<{ tenant: string }> }>;
  apiRoute: string;
}

// File: E:\Dev\websites\repairradar\src\shared\modules\work-orders\api\route.ts


// src/app/api/work-orders/route.ts
import { NextResponse } from "next/server";
import { prisma } from "@/shared/lib/db";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { CreateWorkOrderInput } from "@/shared/modules/types";

export async function GET(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  const url = new URL(req.url);
  const tenantSubdomain = url.searchParams.get("tenantId");
  const tenant = await prisma.tenants.findUnique({ where: { subdomain: tenantSubdomain || undefined, deletedAt: null } });
  if (!tenant) return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
  const workOrders = await prisma.workOrder.findMany({
    where: { tenantId: tenant.id, deletedAt: null },
    include: { assets: { include: { asset: true } }, notes: true, assignedTo: true },
  });
  return NextResponse.json(workOrders);
}

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== "ADMIN" && session.user.role !== "SUPER_ADMIN")) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { tenantId: tenantSubdomain, description, assetIds, priority, dueDate, assignedToId, notes } = await req.json() as CreateWorkOrderInput;
  const tenant = await prisma.tenants.findUnique({ where: { subdomain: tenantSubdomain } });
  if (!tenant) return NextResponse.json({ error: "Tenant not found" }, { status: 404 });
  const validAssets = await prisma.asset.findMany({ where: { id: { in: assetIds }, tenantId: tenant.id, deletedAt: null } });
  if (validAssets.length !== assetIds.length) return NextResponse.json({ error: "Invalid assets" }, { status: 400 });
  const workOrder = await prisma.workOrder.create({
    data: {
      description,
      status: "PENDING",
      tenantId: tenant.id,
      priority: priority || "MEDIUM",
      dueDate: dueDate ? new Date(dueDate) : null,
      assignedToId,
      assets: { create: assetIds.map((assetId: string) => ({ assetId })) },
      notes: notes ? { create: notes.map((note: string) => ({ note, createdById: session.user.id })) } : undefined,
    },
    include: { assets: { include: { asset: true } }, notes: true },
  });
  return NextResponse.json(workOrder, { status: 201 });
}

export async function PUT(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== "ADMIN" && session.user.role !== "SUPER_ADMIN")) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const url = new URL(req.url);
  const id = url.searchParams.get("id");
  const { status, assignedToId, newNotes, assetIds } = await req.json();
  if (!id) return NextResponse.json({ error: "Missing work order ID" }, { status: 400 });
  const workOrder = await prisma.workOrder.update({
    where: { id, deletedAt: null },
    data: {
      status,
      assignedToId,
      assets: assetIds ? {
        deleteMany: {},
        create: assetIds.map((assetId: string) => ({ assetId })),
      } : undefined,
      notes: newNotes ? { create: newNotes.map((note: string) => ({ note, createdById: session.user.id })) } : undefined,
    },
    include: { assets: { include: { asset: true } }, notes: true },
  });
  return NextResponse.json(workOrder);
}

export async function DELETE(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || (session.user.role !== "ADMIN" && session.user.role !== "SUPER_ADMIN")) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const url = new URL(req.url);
  const id = url.searchParams.get("id");
  if (!id) return NextResponse.json({ error: "Missing work order ID" }, { status: 400 });
  await prisma.workOrder.update({ where: { id }, data: { deletedAt: new Date() } });
  return NextResponse.json({ message: "Work order soft deleted" });
}

// File: E:\Dev\websites\repairradar\src\shared\modules\work-orders\components\WorkOrdersPage.tsx


"use client";
import { useSession } from "next-auth/react";
import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { toast } from "sonner";
import { ChevronDown, Edit, Loader2, Plus, RefreshCw, Search, Trash2 } from "lucide-react";
import { WorkOrder, Asset, WorkOrderPriority, WorkOrderStatus } from "@prisma/client";
import { EditDialog } from "@/components/EditDialog";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";

type WorkOrderWithRelations = WorkOrder & {
  assets: { asset: Asset }[];
  notes: { note: string; createdAt: Date }[];
  assignedTo?: { email: string } | null;
};

export default function WorkOrdersPage({ tenant }: { tenant: string }) {
  const { status } = useSession();
  const router = useRouter();
  const [workOrders, setWorkOrders] = useState<WorkOrderWithRelations[]>([]);
  const [assets, setAssets] = useState<Asset[]>([]);
  const [loading, setLoading] = useState(true);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [filterStatus, setFilterStatus] = useState<WorkOrderStatus | "all">("all");
  const [priorityFilter, setPriorityFilter] = useState<WorkOrderPriority | "all">("all");
  const [newWorkOrder, setNewWorkOrder] = useState({
    description: "",
    assetIds: [] as string[],
    priority: "MEDIUM" as WorkOrderPriority,
    dueDate: ""
  });
  const [isCreating, setIsCreating] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [currentWorkOrder, setCurrentWorkOrder] = useState<WorkOrderWithRelations | null>(null);

  // Fetch data
  const fetchWorkOrders = useCallback(async () => {
    try {
      const res = await fetch(`/api/work-orders?tenantId=${tenant}`);
      if (!res.ok) throw new Error(await res.text());
      const data: WorkOrderWithRelations[] = await res.json();
      setWorkOrders(data);
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to fetch work orders");
    }
  }, [tenant]);

  const fetchAssets = useCallback(async () => {
    try {
      const res = await fetch(`/api/assets?subdomain=${tenant}`);
      if (!res.ok) throw new Error(await res.text());
      setAssets(await res.json());
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to fetch assets");
    }
  }, [tenant]);

  const handleRefresh = useCallback(async () => {
    setIsRefreshing(true);
    try {
      await Promise.all([fetchWorkOrders(), fetchAssets()]);
    } catch (error) {
      console.error("Refresh failed:", error);
    } finally {
      setIsRefreshing(false);
    }
  }, [fetchWorkOrders, fetchAssets]);

  // Filter and sort work orders
  const filteredWorkOrders = useCallback(() => {
    return workOrders
      .filter(wo => {
        const matchesSearch = searchTerm === "" || 
          wo.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
          wo.assets.some(a => 
            a.asset.name.toLowerCase().includes(searchTerm.toLowerCase())
          );
        
        const matchesStatus = filterStatus === 'all' || wo.status === filterStatus;
        const matchesPriority = priorityFilter === 'all' || wo.priority === priorityFilter;
        
        return matchesSearch && matchesStatus && matchesPriority;
      })
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
  }, [workOrders, searchTerm, filterStatus, priorityFilter]);

  // Handle form submissions
  const handleCreateWorkOrder = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newWorkOrder.description || newWorkOrder.assetIds.length === 0) {
      toast.error("Description and at least one asset are required");
      return;
    }

    try {
      const res = await fetch("/api/work-orders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ 
          tenantId: tenant, 
          ...newWorkOrder 
        }),
      });

      if (!res.ok) throw new Error(await res.text());

      setNewWorkOrder({
        description: "",
        assetIds: [],
        priority: "MEDIUM",
        dueDate: ""
      });
      setIsCreating(false);
      await handleRefresh();
      toast.success("Work order created successfully");
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to create work order");
    }
  };

  const handleUpdateWorkOrder = async (updates: Partial<WorkOrder>) => {
    if (!currentWorkOrder) return;

    try {
      const res = await fetch(`/api/work-orders?id=${currentWorkOrder.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updates),
      });

      if (!res.ok) throw new Error(await res.text());

      await handleRefresh();
      setEditDialogOpen(false);
      toast.success("Work order updated successfully");
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to update work order");
    }
  };

  const handleDeleteWorkOrder = async (id: string) => {
    if (!confirm("Are you sure you want to delete this work order?")) return;

    try {
      const res = await fetch(`/api/work-orders?id=${id}`, { 
        method: "DELETE" 
      });
      
      if (!res.ok) throw new Error(await res.text());

      await handleRefresh();
      toast.success("Work order deleted");
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "Failed to delete work order");
    }
  };

  // Initial data load
  useEffect(() => {
    if (status === "unauthenticated") {
      router.push("/auth/signin");
    } else if (status === "authenticated") {
      handleRefresh().finally(() => setLoading(false));
    }
  }, [status, router, handleRefresh]);

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold">Work Orders</h1>
          <p className="text-muted-foreground">Manage maintenance and service requests</p>
        </div>
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleRefresh}
            disabled={isRefreshing}
          >
            {isRefreshing ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <RefreshCw className="h-4 w-4 mr-2" />
            )}
            Refresh
          </Button>
          <Button onClick={() => setIsCreating(!isCreating)}>
            <Plus className="h-4 w-4 mr-2" />
            New Work Order
          </Button>
        </div>
      </div>

      <Card>
        <CardHeader className="pb-0">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
            <div>
              <CardTitle>Work Order Management</CardTitle>
              <CardDescription>
                {filteredWorkOrders().length} {filteredWorkOrders().length === 1 ? 'order' : 'orders'} found
              </CardDescription>
            </div>
            <div className="flex flex-col md:flex-row gap-3">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search work orders..."
                  className="pl-9"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
              <Select 
                value={filterStatus}
                onValueChange={(val) => setFilterStatus(val as WorkOrderStatus | "all")}
              >
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Filter status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Statuses</SelectItem>
                  <SelectItem value="PENDING">Pending</SelectItem>
                  <SelectItem value="IN_PROGRESS">In Progress</SelectItem>
                  <SelectItem value="COMPLETED">Completed</SelectItem>
                  <SelectItem value="CANCELLED">Cancelled</SelectItem>
                </SelectContent>
              </Select>
              <Select 
                value={priorityFilter}
                onValueChange={(val) => setPriorityFilter(val as WorkOrderPriority | "all")}
              >
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Filter priority" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Priorities</SelectItem>
                  <SelectItem value="LOW">Low</SelectItem>
                  <SelectItem value="MEDIUM">Medium</SelectItem>
                  <SelectItem value="HIGH">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </CardHeader>
        <CardContent>
          {isCreating && (
            <form onSubmit={handleCreateWorkOrder} className="mb-6 p-4 border rounded-lg bg-muted/50">
              <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div className="md:col-span-2">
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Description *
                  </label>
                  <Input
                    value={newWorkOrder.description}
                    onChange={(e) => setNewWorkOrder({...newWorkOrder, description: e.target.value})}
                    placeholder="Describe the work needed..."
                    required
                  />
                </div>
                <div>
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Priority *
                  </label>
                  <Select
                    value={newWorkOrder.priority}
                    onValueChange={(val) => setNewWorkOrder({...newWorkOrder, priority: val as WorkOrderPriority})}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select priority" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="LOW">Low</SelectItem>
                      <SelectItem value="MEDIUM">Medium</SelectItem>
                      <SelectItem value="HIGH">High</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div>
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Due Date
                  </label>
                  <Input
                    type="date"
                    value={newWorkOrder.dueDate}
                    onChange={(e) => setNewWorkOrder({...newWorkOrder, dueDate: e.target.value})}
                  />
                </div>
                <div className="md:col-span-2">
                  <label className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70 mb-1 block">
                    Assets *
                  </label>
                  <Select
                    onValueChange={(value) => {
                      if (!newWorkOrder.assetIds.includes(value)) {
                        setNewWorkOrder({
                          ...newWorkOrder,
                          assetIds: [...newWorkOrder.assetIds, value]
                        });
                      }
                    }}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select assets" />
                    </SelectTrigger>
                    <SelectContent>
                      {assets.filter(a => !newWorkOrder.assetIds.includes(a.id)).map((asset) => (
                        <SelectItem key={asset.id} value={asset.id}>
                          {asset.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {newWorkOrder.assetIds.length > 0 && (
                    <div className="mt-2 flex flex-wrap gap-2">
                      {newWorkOrder.assetIds.map(id => {
                        const asset = assets.find(a => a.id === id);
                        return asset ? (
                          <Badge 
                            key={id} 
                            variant="outline"
                            className="flex items-center gap-1"
                          >
                            {asset.name}
                            <button
                              type="button"
                              onClick={() => setNewWorkOrder({
                                ...newWorkOrder,
                                assetIds: newWorkOrder.assetIds.filter(aid => aid !== id)
                              })}
                              className="text-muted-foreground hover:text-destructive"
                            >
                              Ã—
                            </button>
                          </Badge>
                        ) : null;
                      })}
                    </div>
                  )}
                </div>
                <div className="flex items-end gap-2">
                  <Button 
                    type="submit" 
                    disabled={!newWorkOrder.description || newWorkOrder.assetIds.length === 0}
                  >
                    <Plus className="h-4 w-4 mr-2" />
                    Create Work Order
                  </Button>
                  <Button 
                    variant="outline" 
                    type="button"
                    onClick={() => setIsCreating(false)}
                  >
                    Cancel
                  </Button>
                </div>
              </div>
            </form>
          )}

          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Description</TableHead>
                  <TableHead>Assets</TableHead>
                  <TableHead>Priority</TableHead>
                  <TableHead>Status</TableHead>
                  <TableHead>Due Date</TableHead>
                  <TableHead className="text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredWorkOrders().length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={6} className="h-24 text-center">
                      {searchTerm ? 'No matching work orders found' : 'No work orders available'}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredWorkOrders().map((wo) => (
                    <TableRow key={wo.id}>
                      <TableCell className="font-medium">
                        {wo.description}
                      </TableCell>
                      <TableCell>
                        <div className="flex flex-wrap gap-1">
                          {wo.assets.map(({ asset }) => (
                            <Badge key={asset.id} variant="outline">
                              {asset.name}
                            </Badge>
                          ))}
                        </div>
                      </TableCell>
                      <TableCell>
                        <Badge 
                          variant={
                            wo.priority === 'HIGH' ? 'destructive' :
                            wo.priority === 'MEDIUM' ? 'secondary' : 'default'
                          }
                        >
                          {wo.priority}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <Badge 
                          variant={
                            wo.status === 'COMPLETED' ? 'default' :
                            wo.status === 'IN_PROGRESS' ? 'secondary' :
                            wo.status === 'CANCELLED' ? 'destructive' : 'outline'
                          }
                        >
                          {wo.status.split('_').join(' ')}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        {wo.dueDate ? new Date(wo.dueDate).toLocaleDateString() : 'N/A'}
                      </TableCell>
                      <TableCell className="text-right">
                        <DropdownMenu>
                          <DropdownMenuTrigger asChild>
                            <Button variant="ghost" size="sm">
                              Actions <ChevronDown className="ml-1 h-4 w-4" />
                            </Button>
                          </DropdownMenuTrigger>
                          <DropdownMenuContent align="end">
                            <DropdownMenuItem 
                              onClick={() => {
                                setCurrentWorkOrder(wo);
                                setEditDialogOpen(true);
                              }}
                            >
                              <Edit className="h-4 w-4 mr-2" />
                              Edit
                            </DropdownMenuItem>
                            <DropdownMenuItem
                              onClick={() => handleDeleteWorkOrder(wo.id)}
                              className="text-red-600"
                            >
                              <Trash2 className="h-4 w-4 mr-2" />
                              Delete
                            </DropdownMenuItem>
                          </DropdownMenuContent>
                        </DropdownMenu>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        </CardContent>
      </Card>

      <EditDialog
        open={editDialogOpen}
        onOpenChange={(open) => {
          setEditDialogOpen(open);
          if (!open) setCurrentWorkOrder(null);
        }}
        title="Edit Work Order"
        description="Update work order details"
        initialData={{
          description: currentWorkOrder?.description || '',
          priority: currentWorkOrder?.priority || 'MEDIUM',
          status: currentWorkOrder?.status || 'PENDING',
          dueDate: currentWorkOrder?.dueDate?.toISOString() || ''
        }}
        fields={[
          {
            name: 'description',
            label: 'Description',
            type: 'text',
            required: true
          },
          {
            name: 'priority',
            label: 'Priority',
            type: 'select',
            options: [
              { value: 'LOW', label: 'Low' },
              { value: 'MEDIUM', label: 'Medium' },
              { value: 'HIGH', label: 'High' }
            ]
          },
          {
            name: 'status',
            label: 'Status',
            type: 'select',
            options: [
              { value: 'PENDING', label: 'Pending' },
              { value: 'IN_PROGRESS', label: 'In Progress' },
              { value: 'COMPLETED', label: 'Completed' },
              { value: 'CANCELLED', label: 'Cancelled' }
            ]
          },
          {
            name: 'dueDate',
            label: 'Due Date',
            type: "datetime"
          }
        ]}
        onSubmit={(data) => handleUpdateWorkOrder(data)}
      />
    </div>
  );
}


// File: E:\Dev\websites\repairradar\tailwind.config.js


/** @type {import('tailwindcss').Config} */
module.exports = {
    darkMode: "class",
    content: [
      "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {
        borderRadius: {
          lg: "var(--radius)",
          md: "calc(var(--radius) - 2px)",
          sm: "calc(var(--radius) - 4px)",
        },
      },
    },
    plugins: [import("tailwindcss-animate")],
  };